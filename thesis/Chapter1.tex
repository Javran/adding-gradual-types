%Chapter 1

% \renewcommand{\thechapter}{1}

\section{Introduction}

% TODO: about detect and localize error

Type system defines sets of rules about programs, which can be checked by a machine
in a systematic way.
One can assign types to appropriate language concepts like
variables, functions and classes to describe expected behaviors
and how they interact with each other.
Then type system takes the responsibility of ensuring that types are respected and
type errors prevent erroneous part of a program from execution.

There are other benefits of type systems besides automated checking:
types can be used to reveal optimization opportunities,
can serve as simple documentation to programmers or
provide hints to development tools to allow auxiliary features like
automate navigation, documentation lookup
or auto-completion.

All these benefits make type system an important part of programming languages,
and there are different ways of accommodating languages with type systems.
The most noticeable difference is the process of checking programs again type rules,
which is also known as type checking.
It occurs either statically ahead of program execution, or dynamically at runtime.
For a static type system, ill-typed programs are rejected by compiler and
no executable can be produced until all type errors are fixed.
For a dynamic type system,
type information is examined at runtime and type errors result
in abortion of the program or exceptions being raised
instead of causing segmentation faults or other worse consequences.
Static and dynamic type system both have their advantages and disadvantages,
and languages make different choices depending on their needs.

In this section, we start off by discussing static and dynamic type systems,
which have inspired many lines of research that combine both within one system.
One instance among them is gradual typing, the main focus of this survey.

\subsection{Strengths and Weaknesses of Static and Dynamic Typing}

The difference between static and dynamic typing is the difference
between whether type checking occurs ahead of execution or at runtime.
This section discusses advantages and disadvantages of both.

\newcommand{\tnum}{\textbf{num}}
\newcommand{\tstr}{\textbf{str}}
\newcommand{\tbool}{\textbf{bool}}
\newcommand{\tarr}[2]{#1 \rightarrow #2}

\subsubsection{Notation}
In the following sections we use $\tau_0, \tau_1, \ldots$ for type variables.
$\tbool$, $\tnum$ and $\tstr$ are types of
boolean values, numbers and strings respectively.\
Tuple types are notated as $(\tau_0, \tau_1, \ldots)$,
and the type notation for functions that takes as input a value of type $\tau_0$
and returns a value of $\tau_1$ is $\tarr{\tau_0}{\tau_1}$.
We use $o : \tau$ to mean that a term $o$ is assigned type $\tau$.
For example $f : \tarr{(\tnum, \tnum)}{\tnum}$ is a function that
takes a tuple of two numbers as input and returns a number.

\subsubsection{Static Type Systems}

A static type system is preferred if robustness and performance
is the main goal of a language.
Because type checking occurs ahead of execution,
ill-typed programs are rejected before it can start, and
when a program typechecks,
one can therefore expect no type error to occur and
no extra cost of typechecking is paid at runtime.

For a static type system to work, all variables, functions, etc. in a program
will need to be assigned types. This is usually done by programmers or through the
means of type inference, which is a technique that infers types using
available type information. This is both an advantage and a disadvantage
of a static type system: having type annotations improves readability
and since programmers are required to keep the consistency between type and code,
type also serves as simple, faithful documentation.
But on the other hand, extra maintenance on type annotations
is required just to allow program execution. This might
be undesirable in situations where a trial-and-error style of programming
is preferable.

Having static known type information also helps in terms of performance.
For example, In machine instructions, primitive arithmetic operations
would only deal with operands of compatible types: addition can only add together
two integers or two floating numbers.
However, in many programming languages,
addition is polymorphic and when it comes to the case of adding an integer
and an floating number, the integer is implicitly converted into a floating number before
performing the actual addition.
For a statically typed system, type information can be used ahead of execution
to figure out exactly whether it is necessary to insert conversions
and where they are required.
But a dynamic typed language might struggle because type information
is only available at runtime.
As a consequence, similar decisions about conversions have to be made at runtime,
imposing performance penalty.

Besides extra effort of maintaining type annotations,
the disadvantage of a statically type language often lies in the lack of runtime flexibility.
If we want to write a program that deals with data whose structure is
unknown at compile time, runtime inspection must be possible.
While typical dynamically typed languages allow inspect of types or object properties,
some extra work are required for a statically typed language
to maintain and check runtime type information.

In addition, it is often less convenient for programmers to prototype
in statically typed languages: it involves trial and error to find the best implementation
to solve a problem, which means the ability to write partial programs,
make frequent changes to structure of variables and functions, but these features are not easily available for a statically typed language.

\subsubsection{Dynamic Type Systems}

Dynamic type systems do typechecking at runtime, which is best suited for
languages designed for scripting and fast prototyping.
A shell script, for example, runs other executables and feeds one's output to another,
effectively gluing programs together.
In such a case, we have little to no knowledge about these executables ahead of time,
making statically type checking improbable.
And when it comes to prototyping,
it is usually more important to allow a trial-and-error type of style of programming
over concerns about robustness and correctness.
% TODO: bypassing is sufficient
In such scenario, it is more convenient if the type system does not prevent
an incomplete or ill-typed program from execution.

However, it is also easy to spot weaknesses of dynamic type systems.
Despite that dynamically typed languages do not often provide a way of writing type annotations,
programmers usually have facts about behaviors of programs.
These facts are often described in comments or through the naming of variables and functions without a systematic way of verifying them.
As program develops, it is easy to make changes but leaving these descriptions untouched.
This troubles future maintainers to locate the problem and rediscover new facts,
causing maintenance difficulties.

%TODO: throw error at runtime
Furthermore, without type information statically available,
dynamic type system needs to maintain runtime information
and rely on it to implement expected semantics.
For example, if it is allowed for a language to condition on non-boolean values,
its type has to be available at runtime in order to
determine how to interpret its value as a boolean at runtime.

Opportunity of optimization could also be obscured for a dynamically type language.
Array cloning, as an example,
can be implemented efficiently as memory copy instructions
knowing the array in question contains only primitive values but no reference or pointers.
But without prior knowledge like this,
every element of the array has to be traversed and even recursively cloned,
which is the usual case for dynamically typed languages without sophisticated mechanism
of optimization.

\subsection{Combining the benefits of the two}

One might have noticed that static type systems and dynamic type systems
are not incompatible in a fundamental level:
the former does type checking ahead of execution while
the latter maintain and inspect type information at runtime.

Indeed, researchers have been looking at different angles of
the possibility of integrating these two type disciplines within one.
Several lines of research are motivated,
and in this section, we will discuss about these research works.

\subsubsection{Design Goals}

Summarizing pros and cons of static and dynamic typed languages,
we now have a picture of a resulting type system integrating the two,
it should be able to:

\begin{itemize}
	\item \textbf{Detect and rule out type errors ahead of program execution.}
	This is one main purpose of having a static type system.
	When a program starts running, type errors should already be eliminated,
	leaving no need of typechecking during execution.

	% TODO: no better words for now
	\item \textbf{Delay typechecking until it is required at runtime.}
	A dynamic type system is known for its permissiveness on what programs it can accept:
	ill-typed or partially written programs are still allowed to execute
	all the way to its termination or until reaching their incomplete or ill-typed parts.
	This makes it suitable in situations where static type information
	is limited or fast prototyping is preferred over robustness or runtime performance.
\end{itemize}

Aside from these two goals,
a statically typed language receives benefits from
utilizing type information for other purposes like
optimization or providing hints to development tools.
For the resulting system, we should be able to have these benefits as well.

\subsubsection{A Introduction to Gradual Typing}

\newcommand{\dyn}{\textbf{dyn}}

Gradual typing \cite{siek2006gradual} is one possible approach that meets our design goals.
It captures the fact that type information might only be partially known
ahead of execution by introducing a special type that indicates partial types.
It attempts to typecheck programs like a static type system does, but delays
typechecking on partial types until sufficient type information is available
at runtime.

In the following sections, we will introduce it
as an extension to static type system.
But it is also possible and practical to support gradual typing by
extending a dynamic type system.
In fact, there are more instances of dynamically typed languages
making extensions to support gradual typing than that of statically typed ones.

\paragraph{Dynamic Type and Type Consistency}

In order to capture the idea that type information might only be partially known
ahead of execution, gradual type system introduces a special type, 
which is called ``dynamic type'' by convention, on top of a static type system
and extends type judgment to allow a more permissive form of type checking in the presence
of dynamic types. For the rest of this survey,
we will use type $\dyn$ to indicate dynamic types in appropriate contexts.

To demonstrate necessary changes to type judgments,
we use statically typed lambda calculus as a starting point.

All type rules are preserved except for function applications,
which are replaced by two rules in gradually typed lambda calculus:

% As for the type judgment extension, all bindings sites are extended to support 

\begin{math}
\inferrule*[left=(GAPP1)]
{\Gamma \vdash_G e_1 : \dyn \\ \Gamma \vdash e_2 : \tau_2 }
{\Gamma \vdash_G e_1 e_2 : \dyn}
\end{math}

\begin{math}
\inferrule*[left=(GAPP2)]
{\Gamma \vdash_G e_1 : \tarr{\tau}{\tau'} \\ \Gamma \vdash_G e_2 : \tau_2 \\ \tau_2 \sim \tau }
{\Gamma \vdash_G e_1 e_2 : \tau'}
\end{math}


%TODO XXX

To deal with dynamic types, type consistency is introduced
to accommodate type judgments for gradual typing.
Figure ? shows rules for type consistency relation.


\begin{math}
\inferrule*[left=(CREFL)]{ }{\tau \sim \tau}
\inferrule*[left=(CFUNC)]
  {\sigma_1 \sim \tau_1 \\ \sigma_2 \sim \tau_2}
  {\tarr{\sigma_1}{\sigma_2} \sim \tarr{\tau_1}{\tau_2} }
\end{math}

\begin{math}
\inferrule*[left=(CUNR)]{ }{\tau \sim \dyn}
\inferrule*[left=(CUNL)]{ }{\dyn \sim \tau}
\end{math}

In general, two types are consistent when
their type structures do not conflict with each other.
For example, $\tbool$ is consistent with type $\dyn$
despite that the latter is less precise;
$\tarr{\tnum}{\dyn}$ is consistent with both $\tarr{\dyn}{\tnum}$ and $\tarr{\dyn}{\dyn}$,
because all these types are functions that accepts one value and returns another and
$\tnum$ and $\dyn$ are consistent with each other.
However $\tarr{\dyn}{\dyn}$ is never consistent with $\tbool$,
because the former is a function type while the latter a boolean value,
whose type structures do not match.

In order to perform static typechecking, it is required that
all terms in the program to must have types ahead of execution.
In a gradual type system, this is no longer required:
for a specific term,
if programmers choose not to give a type annotation, it will be assigned type $\dyn$.
This still allows static typechecking to detect errors because
for types that contains $\dyn$, it is not totally ignored, but checked
up to the point where the structure of type is known.

On the other hand, a dynamically type program can now be statically typechecked
by considering it to be a program without any type annotation.
This is still beneficial, as some literal values and primitives will still have their built-in types,
an obvious misuse like taking the square root of a string value can now be detected ahead of execution
instead of raising runtime exceptions.

\paragraph{Cast Insertion and Runtime Typechecking}

As we can see gradual type system attempts to contain both statically and dynamically typed programs.
However, because of presence of dynamic types,
the type system cannot be sound by only have static typechecking.
Imagine function $f : \tarr{\tnum}{\dyn}$ and variable $v : \dyn$, while the function application
$f v$ can pass static typechecking, the runtime value of $t$ might turn out to be a string
and now the application is ill-typed.

The problem lies in the fact that some terms might be assigned with types that contains
$\dyn$, its runtime counterpart are precise, which is not checked during static typechecking.
To solve this problem, casts are inserted at appropriate locations, which then
allows type errors to be detected at runtime.
Suppose we have a cast function $c : \tarr{\dyn}{\tnum}$, function application $f v$
then becomes $f (c v)$, which still typechecks, but whenever we need to pass a runtime value to $f$,
its runtime is always checked by $c$ to decide whether to pass the value to $f$ or raise
a type error.
%TODO: from Gradual Typing for Functional Languages

\paragraph{Optional Type Annotation and ``pay-as-you-go''}

So far we have seen that gradual type system introduces a dynamic type,
which allows accepting both statically and dynamically typed programs during static typechecking.
But what is more important is that it creates a middle ground in which programs
can be partially annotated with types:
in a gradual type system, terms are either explicitly given a type,
or, when type annotation is missing, given $\dyn$ type.
This renders all type annotations to be optional and allows programmers
to have more control over what they need from typechecking:
for an originally statically typed program, we can now write terms without giving a type,
this allows easy prototyping; for an originally dynamically typed program,
some parts of it might already been stable and robust enough, annotating these parts
with type allows some effort of ensuring correctness being shifted to typechecking.

For example, one might wish to implement a function $f$ that expects a string value
as input. There are two approaches: we can either give $f$ a type annotation:
$f : \tarr{\textbf{str}}{\dyn}$. By doing so, type system takes the responsibility
of making sure that the input type is indeed a string. Alternatively,
we can inspect type of the input value at runtime ourselves.
A static type system allows us to do the former, but a return type must either
be given explicitly or inferred. And a dynamic type system does the later, but
we cannot statically detect any mistake like applying a number literal to $f$.
However, a gradual type system finds the balance between two,
it allows us to give input value a type without worrying about
giving a return type if not needed,
therefore programmer only pays for what they want from a type system.

%TODO more to say



\paragraph{Gradual Guarantee}

Regarding the term gradual typing itself,
Siek, Vitousek, Cimini and Boyland's work gives a detailed explanation of
the original intention.
Several works we are going to discuss in the following few chapters respects
such idea:

\begin{itemize}
	\item \textbf{Gradual typing includes both fully static and fully dynamic}
	A gradually typed language should be a superset of both a statically typed
	language and a dynamically typed one.
	Except for cases of type errors, evaluating a fully type-annotated program
	should have the same result as its untyped counterpart.
	\item \textbf{Gradual typing provides sound interoperability}
	\item \textbf{Gradual typing enables gradual evolution}
\end{itemize}


\subsubsection{Alternatives}

There are other type systems that bring benefits of the two together.
Cartwright and Fagan's introduced soft typing, which is a type system
that programers do not write type annotations but use type inference to
assign appropriate types to terms, and runtime checks are inserted as needed.
The drawback of this design is that programmers do not have control over types.
%TODO probably more drawbacks
Quasi-static typing is another attempt, with the idea of dynamic type in use,
it chooses to use a subtyping relation and allows both up-casts and down-casts.
A second pass of plausibility checking detects incompatible casts and signals the program
in question as ill-typed. However its typechecking algorithm did not receive a correct proof,
and it does not statically catch all type errors (TODO: ref)
in the process of attempting the proof, Siek and Taha finds a better solution, 
which results in gradual typing that we have seen today.
%TODO? 

\subsubsection{Discussion}

Among various research works that combines
benefit of static and dynamic type checking
gradual typing remains one of the most popular approach.
In the sprite of gradual guarantee, gradual typing extensions aim at
making all existing programs written in the original one still valid with little difference in semantics.
In addition, unlike other approaches, programmers have better control over should and should not be typechecked.

Despite that gradual type systems are well-studied research topics,
extending existing languages to support them is far from trivial task.
To name few differences, while theoretical type systems assume primitive types as simple as just numbers and booleans,
a practical language have various kinds of them including integers, floating numbers, strings and arrays,
which have not been addressed much.
In addition, language-specific features, idioms and common practice needs
to be carefully studied to allow existing code and language users to transit smoothly into
the extended language. In this survey we will explore literatures that extends existing languages to support gradual typing.
In chapter 2, we will focus on benefits of making these extensions. Chapter 3 discusses and categorizes common and language-specific
challenges researchers have to face and solutions to them.
Some of these challenges, however, still remains as open questions, which will be covered in chapter 4.

