%Chapter 2

\renewcommand{\thechapter}{2}

\chapter{Extending existing languages}

Gradual type system features optional type annotations with soundness,
which is compatible with both statically and dynamically typed programs,
type safety are preserved and semantics are kept consistent.
This makes it an ideal type system that
existing languages can be extended to support.

In this chapter, we will explore some research works that extends existing languages
to support gradual typing. As we will see, this is not a trivial task:
since it requires the extended language to still support existing programs written
in the original language with little to none modification,
language features, idiom and practice commonly used among its community
needs to be carefully understood to allow a smooth and non-intrusive experience.

\section{From JavaScript to TypeScript}

Starting as a scripting language, JavaScript has grown into a language
that powers many large web applications.
Unfortunately, as a language that exists over a long period of time,
the language evolves but many of its flaws are still left as it is for compatibility reasons,
hindering productivity of many programmers.

Among tools and extensions to JavaScript that attempt to ease this pain,
TypeScript is one closely related to gradual typing:
it is a superset of JavaScript that supports optional type annotations,
a compiler typechecks TypeScript code ahead of execution and compile code
into plain JavaScript source code, making it ready to be executed out of box
for JavaScript engines.
However, TypeScript is intentionally unsound: only static typechecking is performed,
which does not prevent runtime type errors.
One noticeable improvement to TypeScript is Safe TypeScript by Rastogi, Swamy, Fournet, Bierman \& Vekris, which shares the same syntax with TypeScript
but features a sound type system and efficient runtime type information (RTTI)-based
gradual typing.

In this section we will visit some language features of Safe TypeScript and see how it improves JavaScript.

\subsection{Type Checking for Free}

Despite JavaScript is capable of examining type of values at runtime,
it does not have support for type annotations.
This leads to a common practice in which function bodies will have code
just for checking its argument types and throw errors before
proceeding with actual implementation:

\begin{verbatim}
function f(x) {
    if (typeof x !== 'string') {
        // throw error
    }
    return x + '!';
}
\end{verbatim}

As a toy example, the function accepts a string value,
then returns another with exclamation sign concatenated to it. 
But imagine in real projects there will be multiple arguments to a function
and some of them have to go through this process of checking,
it will soon become less maintainable.

By extending the language with type annotations,
we can do something better in Safe TypeScript:

\begin{verbatim}
function f(x : string) : string {
    // now this check becomes unnecessary
    if (typeof x !== 'string') {
        // throw error
    }
    return x + '!';
}
\end{verbatim}

In the code above, we just declared a function $\textbf{f}$ that accepts
one variable $x$ of $\textbf{string}$ type, and returns a value of $\textbf{string}$ type.
The code for runtime checking is removed, instead, Safe TypeScript performs typechecking
and insert casts when needed to ensure that,
when $\textbf{f}$ is called, its argument is indeed a $\textbf{string}$.
This renders the  $\textbf{typeof}$ check at the beginning useless:
when we enter the function body $\textbf{x}$ is guaranteed to be a $\textbf{string}$,
therefore the body of the $\textbf{if}$ statement cannot possibly be entered.
This allows us to get rid of the check totally:


\begin{verbatim}
function f(x : string) : string {
    return x + '!';
}
\end{verbatim}

The use site of $\textbf{f}$ might look like the following:

\begin{verbatim}
f('one'); // good
f(1); // bad
function g(x) {
    return f(x); // might be unsafe
}
\end{verbatim}

Here Safe TypeScript is able to tell that: calling $\textbf{f}$ with a string literal
is safe, and no extra cast is needed; the second call is immediately rejected
because number literal is clearly not a $\textbf{string}$;
and for the third case where $\textbf{x}$
is not explicitly given a type, Safe TypeScript compiler will insert runtime type cast
and either allow it to proceed to the body $\textbf{f}$ when $\textbf{x}$ is indeed a string,
or throw an error before even calling $\textbf{f}$.

Notice that by making use of type annotations, Safe TypeScript not only allows
clearer code, but also able to spot some type errors ahead of execution:
imagine the call $\textbf{f(1)}$, when its written in plain JavaScript,
we have to wait for the check in function body to throw an error,
while Safe TypeScript allows annotating $\textbf{x}$ with a type
therefore spots the error even before execution.

\subsection{Nominal class and structural interfaces}

NOTES

(probably showcasing)

Object as map

Object in the sense of OOP

\subsection{Type-safety and encapsulation}

\subsection{RTTI and Performance}


\section{From Scheme to Typed Scheme}



\begin{verbatim}
(define (creal x)
  (cond [(number? x) x]
        [else (car x)]))
\end{verbatim}

occurrence typing

simple macros?

\section{Reticulated Python}


structural typing to match for Python's duck typing

CSharp (this being the only static language that wants interaction with dynamic ones)

syntactic improvement
dynamic Object ("Expando Object")

\section{C$^\sharp$ 4.0}


\section{Gradualtalk}

TODO