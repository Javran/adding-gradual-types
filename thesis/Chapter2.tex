%Chapter 2

\renewcommand{\thechapter}{2}

\chapter{Extending existing languages}

Gradual type system features optional type annotations with soundness,
which is compatible with both statically and dynamically typed programs,
type safety are preserved and semantics are kept consistent.
This makes it an ideal type system that
existing languages can be extended to support.

In this chapter, we will explore some research works that extends existing languages
to support gradual typing. As we will see, this is not a trivial task:
since it requires the extended language to still support existing programs written
in the original language with little to none modification,
language features, idiom and practice commonly used among its community
needs to be carefully understood to allow a smooth and non-intrusive experience.

\section{From JavaScript to Safe TypeScript}

Starting as a scripting language, JavaScript has grown into a language
that powers many large web applications.
Unfortunately, as a language that exists over a long period of time,
the language evolves but many of its flaws are still left as it is for compatibility reasons,
hindering productivity of many programmers.

Among tools and extensions to JavaScript that attempt to ease this pain,
TypeScript is one closely related to gradual typing:
it is a superset of JavaScript that supports optional type annotations,
a compiler typechecks TypeScript code ahead of execution and compile code
into plain JavaScript source code, making it ready to be executed out of box
for JavaScript interpreters.
However, TypeScript is intentionally unsound: only static typechecking is performed,
which does not prevent runtime type errors.
One noticeable improvement to TypeScript is Safe TypeScript by Rastogi, Swamy, Fournet, Bierman \& Vekris, which shares the same syntax with TypeScript
but features a sound type system and efficient runtime type information (RTTI)-based
gradual typing.

In this section we will visit some language features of Safe TypeScript and see how it improves JavaScript. Note that TypeScript uses $\textbf{any}$ for dynamic type.

\subsection{Type Checking for Free}

Despite JavaScript is capable of examining type of values at runtime,
it does not have support for type annotations.
This leads to a common practice in which function bodies will have code
just for checking its argument types and throw errors before
proceeding with actual implementation:

\begin{verbatim}
function f(x) {
    if (typeof x !== 'string') {
        // throw error
    }
    return x + '!';
}
\end{verbatim}

As a toy example, the function accepts a string value,
then returns another with exclamation sign concatenated to it. 
But imagine in real projects there will be multiple arguments to a function
and some of them have to go through this process of checking,
it will soon become less maintainable.

By extending the language with type annotations,
we can do something better in Safe TypeScript:

\begin{verbatim}
function f(x : string) : string {
    // now this check becomes unnecessary
    if (typeof x !== 'string') {
        // throw error
    }
    return x + '!';
}
\end{verbatim}

In the code above, we just declared a function $\textbf{f}$ that accepts
one variable $x$ of $\textbf{string}$ type, and returns a value of $\textbf{string}$ type.
The code for runtime checking is removed, instead, Safe TypeScript performs typechecking
and insert casts when needed to ensure that,
when $\textbf{f}$ is called, its argument is indeed a $\textbf{string}$.
This renders the  $\textbf{typeof}$ check at the beginning useless:
when we enter the function body $\textbf{x}$ is guaranteed to be a $\textbf{string}$,
therefore the body of the $\textbf{if}$ statement cannot possibly be entered.
This allows us to get rid of the check totally:


\begin{verbatim}
function f(x : string) : string {
    return x + '!';
}
\end{verbatim}

The use site of $\textbf{f}$ might look like the following:

\begin{verbatim}
f('one'); // good
f(1); // bad
function g(x) {
    return f(x); // might be unsafe
}
\end{verbatim}

Here Safe TypeScript is able to tell that: calling $\textbf{f}$ with a string literal
is safe, and no extra cast is needed; the second call is immediately rejected
because number literal is clearly not a $\textbf{string}$;
and for the third case where $\textbf{x}$
is not explicitly given a type, Safe TypeScript compiler will insert runtime type cast
and either allow it to proceed to the body $\textbf{f}$ when $\textbf{x}$ is indeed a string,
or throw an error before even calling $\textbf{f}$.

Notice that by making use of type annotations, Safe TypeScript not only allows
clearer code, but also able to spot some type errors ahead of execution:
imagine the function application $\textbf{f(1)}$, when its written in plain JavaScript,
we have to wait for the check in function body to throw an error,
while annotating $\textbf{x}$ with a type allows Safe TypeScript
to spot the error even before execution.

\subsection{Object-Oriented Programming in Safe TypeScript}

%TODO: what technique allos JS to simulate OO?
JavaScript is a prototype-based language.
This means runtime objects form a chain in which one object
can be a prototype of other objects and
to perform method invocation, method names are searched
first in object itself and then along the chain,
and the first one with matching method name is used for the invocation.
Using well-known techniques allows JavaScript to simulate objected-oriented programming.
Designed to be a superset of JavaScript, Safe TypeScript must accommodate such programming
style as well.

TypeScript introduces the concept of interface to allow representing the structure
of runtime objects.

\begin{verbatim}
interface Point { x: number; y: number }
\end{verbatim}

This defines $\textbf{Point}$ type to be an object that has two fields $\textbf{x}$
and $\textbf{y}$ whose types are all $\textbf{number}$s.
For example, the invocation with object literal $f(\textbf{\{x: 1, y: 0\})}$ typechecks
with $f : Point \Rightarrow any$.
An interface can be implemented by classes:

\begin{verbatim}
class MovablePoint implements Point {
  constructor(public x: number, public y: number) {this.x = x; this.y = y;}
  public move(dx: number, dy: number} { this.x += dx; this.y += dy; }
}
\end{verbatim}

While in TypeScript, all classes are viewed structurally, this does not match
with JavaScript semantics. Consider the following function:

\begin{verbatim}
function mustBeTrue(x : MovablePoint) {
  return !x || x instanceof MovablePoint;
}
\end{verbatim}

One might expect this function to always return $\textbf{true}$.
However, a structural view will consider object literal
$v$ = \textbf{\{x: 0, y: 0, move(dx: number, dy:number) {}\}}
to match with $\textbf{MovablePoint}$, but $\textbf{mustBeTrue(v)}$
will return $\textbf{false}$ because JavaScript will expect $v$ to have
$\textbf{MovablePoint}$ somewhere along its prototype chain.

To solve this problem, Safe TypeScript takes a different approach:
it treats class types nominally but can be viewed structurally.
Namely, $\textbf{MovablePoint}$ is still a subtype of
$t_m$ = \textbf{\{x: number, y: number, move(dx: number, dy:number): any\}}
and \textbf{\{x: number, y: number\}}.
But $t_m$ is no longer a subtype of \textbf{MovablePoint}.

%TODO: method & field

%TODO: put this in ch3 \subsection{Type Erasure, information hiding and performance}


\section{From Scheme to Typed Scheme}

Scheme is a dynamically typed language.
It is used for casual scripting as well as industrial applications.
Like other dynamic typed languages, programmers are not attached to using any
type discipline but rely on various kind of reasoning on their needs.
This makes the language flexible but challenging to assign proper and precise types to terms.

Tobin-Hochstadt and Felleisen's work on Typed Scheme
introduces the notion of occurrence typing, which
extends Scheme with gradual typing.

%TODO: type discipline vs type system?

\subsection{Support Informal Reasoning}

The following code shows a function definition as typical style of programming in this language:

\begin{verbatim}
;; a Complex is either
;; - a number
;; - (cons number number)
(define (creal x)
  (cond [(number? x) x]
        [else (car x)]))
\end{verbatim}

The code above defines a function $\textbf{creal}$, which takes as argument
a complex number: a real number is simply a value satisfying $\textbf{number?}$,
while an imaginary number is a pair of $\textbf{number}$.
Function $\textbf{number?}$ distinguishes two different representation of numbers:
in the the first branch of $\textbf{cond}$, $\textbf{x}$ is treated like a number
while in the second branch $\textbf{x}$ is a pair and $\textbf{car}$ is used
to extract its real part.

One might have noticed that
while input value \textbf{x} could be either a number or a pair of numbers,
predicate \textbf{number?} distinguishes between them and
in difference branches of the \textbf{cond} expression, \textbf{x} gets different types.

It is important that type system should be able to assign same variable with different
types depending on the context where variable occurs, this is exactly the notion of
occurrence typing.

The Typed Scheme version begins with definition of complex number:

\begin{verbatim}
;; a Complex is either
;; - a number
;; - (cons number number)
(define-type-alias Cplx (Union Number (cons Number Number)))
\end{verbatim}

While \textbf{Cplx} is just an alias for the union type, it improves readability
and allows other parts of the program to refer to it by name.
The body of the function looks like:

\begin{verbatim}
(define: (creal [x: Cplx]) : Number
  (cond [(number? x) x]
        [else (car x)]))
\end{verbatim}

Note that we are explicitly giving the return type \textbf{Number},
and the type system is capable of inferencing that
both branch of \textbf{cond} expression returns a number
so it will still typecheck.

Another different kind of reasoning is also being used among Scheme programmers:
Suppose we have stored a list of various types of values in \textbf{xs}
and the following code will compute the sum of all numbers from \textbf{xs}:

\begin{verbatim}
(foldl + 0 (filter number? xs))
\end{verbatim}

Note that despite \textbf{xs} is a list that contains not just numbers,
it is guaranteed that \textbf{(filter number? xs)} will return a list of numbers
so \textbf{foldl} will work properly to produce the desired result.

The expression requires no modification at all to typecheck in Typed Scheme
and it receives type system benefits: suppose \textbf{map} is mistakenly
used instead of \textbf{filter} or \textbf{number?} is replaced by
other predicates insufficient to test whether a value in question is indeed a value,
the type system is able to recognize such errors and give warnings.

\subsection{Refinement Type}

Note that in Scheme, we use \textbf{number?} to distinguish numbers
from other type of values.
In general, given a boolean-valued unary function
we can define the set of values that produces \textbf{true} when fed to this function.
This allows Typed Scheme to support refinement type.

\begin{verbatim}
(: just-even (Number -> (Refinement even?)))
(define (just-even n)
  (if (even? n) n (error 'not-even)))
\end{verbatim}

The code above uses boolean-valued function \textbf{even?}
and its corresponding refinement type \textbf{Refinement even?},
so we can expect a value of such type to be not just numbers, but also only even ones.

More practical examples include use refinement types to distinguish raw input
from validated ones:

\begin{verbatim}
(: sql-safe? (String -> Boolean))
(define (sql-safe? s) ...)
(declare-refinement sql-safe?)
\end{verbatim}

In this example, user defines function \textbf{sql-safe?} to verify
that a raw string contains no SQL injection or other contents of malicious attempt.
Then a refinement type is declared using this very function.
This makes available type \textbf{(Refinement sql-safe?)} to rest part of the program
to avoid mistakenly using raw input rather than verified safe ones.

As we can see occurrence typing not just enables
gradual typing, but also allows refinement type,
which provides us a powerful tool to use user-defined functions
to define custom types of better precision.

\section{From Python 3 to Reticulated Python}

Python 3 (Python for short) is another popular dynamic typed language.
M. Vitousek, M. Kent and Baker's work on Reticulated Python (Reticulated for short)
explored extending Python with gradual typing.

Python comes with annotation syntax.
This syntax allows expressions to be optionally attached to
function definitions and their arguments,
which makes it suitable for type annotation.

Given proper definition of \textbf{Int}, we can write annotated
function \textbf{distance} like below:

\begin{verbatim}
def distance(x: Int, y: Int)-> Int:
  return abs(x - y)
\end{verbatim}

While annotation allows arbitrary expressions, Reticulated Python
only uses types built from several type constructors.

\subsection{Function Types}

Python 3 has different ways of calling the same function.
Suppose we want to use \textbf{distance} defined above,
we can use positional arguments like \textbf{distance(3,4)},
or use keywords like \textbf{distance(y=4, x=3)} and the result should be the same.

To support keyword calls, \textbf{Named} constructor is used to give
\textbf{distance} type \textbf{Function(Named(x: Int, y: Int), Int)}.
To support traditional positional arguments, \textbf{Pos} is used instead.
The type system also allows \textbf{Named} to be used as if it is constructed by \textbf{Pos}
when their length and element types correspond. So functions can be called in both
ways without problem. Additionally \textbf{Arb} is another constructor
that allows functions of arbitrary parameters.

\subsection{Class and Object Types}

Python is an object-oriented programming language.
Programmers define classes and create objects from them.
Both classes and objects are runtime values in Python
and Reticulated provides corresponding types for both.

Consider the following example:

\begin{verbatim}
@fields({'x': Int})
class 1DPoint:
  def __init__(self: 1DPoint):
    self.x = 0
  def move(self: 1DPoint, x: Int)->1DPoint:
    self.x += x
    return self

p = 1DPoint()
\end{verbatim}

It defines a class \textbf{1DPoint} with one field \textbf{x} of \textbf{Int} type.
And an object is created from it through the constructor
and is bound to variable \textbf{p}.

Reticulated derives class type from this definition:

\begin{verbatim}
Class(1DPoint){
  move: Function(Named(self: 1DPoint, x: Int), 1DPoint)
}
\end{verbatim}

And object types are similar:

\begin{verbatim}
Object(1DPoint){
  move: Function(Named(x: Int), 1DPoint)
}
\end{verbatim}

While object can access methods of its class, it is also possible
to assign methods and fields to objects to change its behavior.
Therefore Reticulated makes object type open with respect to consistency.

\subsection{Dynamic Semantics}

Reticulated Python is not only a practical gradual type extension,
but serves as an experiment of exploring different dynamic semantics

\subsection{Other Features}

There are other features of Reticulate.
In particular, since it is not always possible to know what module would be loaded
at runtime, static typechecking sometimes occurs right after module is loaded.

Despite Python syntax supports annotation at function definition,
it does not provide a way of annotating local variables with tyoe.
Instead, Reticulated takes a step further and perform dataflow-based type inference.

\section{C$^\sharp$ 4.0}

While we have seen many examples that a dynamically typed language gets
gradual type extensions, Bierman, Meijer and Torgersen's work on
C$^\sharp$ 4.0 shows us a practical example of statically typed language
extends towards gradual typing.
This extension makes interoperation between statically and dynamically typed code
more convenient and brings in features meant for dynamically typed languages.

\subsection{Interaction with Dynamic Objects}

The following code snippet shows how C$^\sharp$ 3.0 interact with JavaScript:

\begin{verbatim}
...
ScriptObject map = win.CreateInstance("VEMap", "myMap");
map.Invoke("LoadMap");
...
string latitude, longtitude;
...
var x = win.CreateInstance("VELatLong", latitude, longitude)
var pin = map.Invoke("AddPushpin", x);
pin.Invoke("SetTitle", name);
...
\end{verbatim}

In order to interact with JavaScript, method calls
are made using string-based interface, which is verbose, fragile to maintain.

With C$^\sharp$ 4.0, the source code can be simplified to:

\begin{verbatim}
...
dynamic map = win.CreateInstance("VEMap", "myMap");
map.LoadMap();
...
string latitude, longtitude;
...
var x = win.CreateInstance("VELatLong", latitude, longitude)
var pin = map.AddPushpin(x);
pin.SetTitle(name);
...
\end{verbatim}

Notice how types are changed to \textbf{dynamic} and methods are called
as if there are regular objects.
These improvements are more than just syntactic: gradual typing is implemented
so that typechecking can be involved and this part of code can benefit from it.

\subsection{Using Features Intended For Dynamic Languages}



dynamic Object ("Expando Object")

\section{From Smalltalk to Gradualtalk}

Smalltalk is a language of highly dynamic nature:
it supports live programming, which means programs with incomplete
methods should be accepted, and programmers in Smalltalk relies on
idioms that are tricky to type properly.
Despite not having many extensions in terms of type system,
Allende, Callau, Fabry, Tanter and Denker's work on Gradualtalk shows
us a well combination of various features in order to extend Smalltalk
into a gradual typed language.

\subsection{Annotate Programs with Types}

\subsection{Self Types}

\subsection{Nominal and Structural Types}

TODO