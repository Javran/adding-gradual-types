\section{Related Work}

\paragraph{Gradual Typing}
Siek and Taha's work on Gradually Typed Lambda Calculus\cite{siek2006gradual}
establishes the theoretical foundation for gradual typing.
It is suggested in the same paper that Cecil\cite{chambers2004cecil}, Boo\cite{de2005boo},
extensions to Visual Basic.NET and \csharp\ proposed by Meijer and Drayton\cite{meijer2004static},
extensions to Java proposed by Gray, Findler and Flatt\cite{gray2005fine}
and the Bigloo \cite{bres2004compiling,serrano2002bigloo} dialect of Scheme\cite{abelson1998revised}
could be formalized using this foundation.
By the same authors,
the idea is pushed further for object-based languages\cite{siek2007gradual}.
As the concept of gradual typing gains its popularity and being used vaguely to
refer to any work regarding integrating of static and dynamic type system,
Siek, Vitousek, Cimini and Boyland present gradual guarantee\cite{siek2015refined}
to reiterate the intention behind gradual typing and serves a more clear guideline for
languages claimed to be gradually typed.

It is also important that gradual type system can deal with
mutable references properly.
Siek and Taha\cite{siek2006gradual} in their original work
simply disallows implicit casts that change the pointed-to type.
Herman, Tomb, and Flanagan\cite{herman2010space} come up with
an improved design that allows implicit casts between reference types
as long as the pointed-to types are consistent.
Siek, Vitousek, Cimini, Tobin-Hochstadt and Garcia\cite{siek2015monotonic}
also proposed a monotonic approach for mutable references.

\paragraph{Soft Typing}
Cartwright and Fagan's Soft Typing\cite{cartwright1991soft},
is a type system intended to free programers from writing type annotations.
Type inference is used instead to assign appropriate types to terms.
While this design improves performance of dynamically typed languages
as the inferred information is used to removing some runtime dispatching,
it does not give programmers control over types.

\paragraph{Like Types}

Wrigstad, Nardelli, Lebresne, {\"O}stlund and Vitek\cite{wrigstad2010integrating}
provides an approach that integrates typed and untyped code
in the language Thorn. They use ``like types'' in the language
to allow static typechecking as well as dynamic checks when
values are bound to the variable in question.
In addition, opportunities for compiler optimization
is still available for the static region of programs.
As suggested in \cite{siek2015refined}, this approach
prioritize on efficiency and does not share goal with gradual typing.

\paragraph{Contracts}

Gradual typing draws work on contracts
by Findler and Felleisen\cite{findler2002contracts,gray2005fine},
which provides a solution when it is required to check function types at runtime.
When applying a cast to a function, the types are not checked immediately.
Instead, when the function is applied, the actual arguments are checked
against argument type. Similarly, when the function returns,
the return value is checked against the return type.

\paragraph{Blame Tracking}

Wadler and Findler's blame tracking\cite{wadler2009well}
provides one approach to keep track of related information with type system,
which allows blames to be assigned properly when the check fails.

\paragraph{Partial Type Systems}
The idea of allowing partial types in a type system is not new.
Anderson and Drossopoulou formalized BabyJ\cite{anderson2003babyj}, which has
nominal type system that allows permissive types.
This concept is similar to dynamic types in a gradual type system.
But unlike gradual typing, the type system is nominal and does not takes into account function types.
Both Thatte's Quasi-Static Typing\cite{thatte1989quasi} relies on subtyping,
which creates a fundamental problem that prevents type system from catching all type errors even when programs are
fully type annotated.
Another type system that relies on subtyping
is developed by Riely and Hennessy\cite{riely1999trust} on a partial type system for D$\pi$,
type \texttt{Ibad} is used for untyped parts. However, by treating \texttt{Ibad} as the bottom type,
it could allow \texttt{Ibad} to be implicitly coercible to arbitrary types.

\paragraph{Type Annotation for Performance}
Some languages includes optional type annotations, but
the annotation is used for improving performance rather than
typechecking.
Common LISP\cite{steele1982overview}
and Dylan\cite{feinberg1996dylan,shalit1996dylan} fall into this category.

\paragraph{Type Inference}
Type inference \cite{damas1982principal,hindley1969principle,milner1978theory}
removes some burden of writing type annotations from programmers
by using available type information to reconstruct types for terms.
It is syntactically similar to gradual typing as both approaches
allow programmer to omit type annotations.
While type inference simply rejects a program when it
does not have sufficient information to fill out all missing types,
a gradual type system allows partial type to present in a program and insert casts
to enforce invariants at runtime instead.
Local type inference \cite{pierce2000local} sometimes are used in a gradual type
system to either free programmers from having to write out all type annotations
or to accommodate the fact that some languages do not have a way of attaching
variables to an explicit type.

\paragraph{Optional Type System}

In an optional type system\cite{bracha2004pluggable},
type annotations are optional and have no impact on the semantics of the language.
Example includes Strongtalk\cite{bracha1993strongtalk}.
While static typechecking is still present, no runtime checks are inserted
so the language does not receive full benefits of a type system.
Nonetheless, sometimes it might be desirable to ensure that certain part of the program
does not have runtime checks inserted by the type system.
Some gradual type systems like Safe TypeScript\cite{rastogi2015safe} does allow writing
types in a specific way to effectively switch some part of the program to use an optional type system.

\paragraph{Type System Integrations}

There are other examples of combining different type systems and taking advantage of both.
Ou, Tan, Mandelbaum and Walker\cite{ou2004dynamic} define a language that combines
standard static typing with dependent typing.
Flanagan's Hybrid Type Checking\cite{flanagan2006hybrid} combines standard static typing
with refinement types. Automated theorem proving technique is employed to try to satisfy predicates
and runtime checks are inserted when theorem prover yields no conclusive results.


