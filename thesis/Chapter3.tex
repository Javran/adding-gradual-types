%Chapter 3

\renewcommand{\thechapter}{3}

\chapter{The Way Towards Gradual Typing}

% TODO: could be organized better?

In previous chapter we have explored the benefits gradual typing
can bring in for existing languages.
There is no canonical way of supporting gradual typing:
it can be extended for either a static typed language or dynamically typed one,
and researchers have to make design choices depending on the nature of the language.
This chapter takes a step further to discuss the way towards making these extensions.
In general, this is not just an effort of putting theories of gradual typing into practical use,
but also introductions of new language features that accomplishes the changes
and helps development for these languages.

\section{Extensions to Type Systems}

Gradual type system supports both fully static and fully dynamic typing,
which requires support for traditional types including
basic type, function type and types for structural data
and a notion of dynamic type to allow presence of partial type information in the system.
Type soundness should be established by a combined work of static and dynamic typechecking.
Additionally, some other interesting extensions are also introduced to provide better
supports for gradual typing.

This section will separate these extensions into two categories:
\textbf{Essential extensions} are required for a complete gradual typing support;
and \textbf{complementary extensions} are those that improves type expressiveness
but a type system without them does not compromise completeness - after all,
explicit types are optional for gradual typing.

\subsection{Essential Extensions}

We are looking at research works that falls into two different type disciplines:
JavaScript, Scheme, Python 3 and Smalltalk are all dynamically typed languages.
And $\csharp$ 3.0 is statically typed language.
While dynamically typed languages share some similarity in their implementations.
The one from $\csharp$ 3.0 is quite a different story.

\subsubsection{Extension from Dynamically Typed Languages}

The approach used by Safe TypeScript and Reticulated Python
is to first perform static typechecking in the presence of dynamic types.
If it is successful, programs written in extended languages are then translated into original languages.
The translated program could contain runtime checks with some values instrumented,
these checks and instruments are either implemented by inserting expressions or statements in place or
making calls to external libraries (which is usually called runtime in short) shipped with
the extended languages.

This ensures a high compatibility with original languages: source code written in extended language
can be compiled and then used as if it is written in the original language, and thanks to the fact
that all existing dynamically typed languages
we are discussing have decent supports for modern package managers,
including runtime support is as simple as making a dependency declaration to package metadata.
Besides, by compiling to the original languages,
we can to some extent be confident that the language implementations
are independent of specific implementations of the original languages,
albeit some language extensions do make assumption about implementations of their original languages.

% Soundness of Typed Scheme?
% Typed Scheme is implemented using PLT Scheme macro system.

% TODO slight issue: TypeScript has 2 static typechecking passes


Gradualtalk is an extension to Pharo Smalltalk. It consists of 3 parts:
the core allows representing types in Smalltalk, the typechecker
is responsible of performing static typechecks and finally
a type dictionary for storing type information.

Typed Scheme takes a similar approach: the implementation is a macro
(a source-to-source transformer) that does typechecking and expands source code.
This phase either results in static type error being reported,
or a working source code in PLT Scheme ready for execution.

\subsection{Extension from A Static Type System}

$\csharp$ is the only statically typed language that we have explored in this survey.
Similar to Siek's original approach, the compiler assign types to terms using built-in knowledge,
explicit type annotations and type inference, then the language is translated into another core
language that consists of less constructions and dynamic types are either turned into
casts or removed in this process to produce the final bytecode ready for execution.

Unlike traditional static type systems, $\csharp$ 3.0 features bidirectional type system.
Such a system have two distinct phases: \textbf{type checking} and \textbf{type synthesize}.
While a type checking phase determines whether a given term can be assigned a particular type,
type synthesize phase works out the expected type from context for a given term. These two phases
are intertwined to produce a fully typed program.

(TODO: achieve transitivity)

\subsection{Complementary Extensions}

While essential extensions establish the completeness of gradual type systems,
complementary extensions are not exactly requirements.
After all, programmers can always choose not to use explicitly typed terms and 
leave types of them inferred or defaulted to dynamic types.
This is however unsatisfactory, as using dynamic types often result in a lost of type information in the process.
Therefore extra features of type systems are usually introduced to improve type expressiveness and 
in general make language more convenient to use.

\subsubsection{Union Types}

Practical languages utilize control flows to have different behaviors depending on situations.
For a dynamically typed language, an expression can usually return values of various possible types.
Typed Scheme and Gradualtalk employ union types to allow preserving more type information.

By notation, an union type $U = \tau_0 \cup \tau_1 \cup \ldots$ typechecks as long as the term in question
typechecks with one of $\tau$.

(TOOD: formal)

\subsubsection{Occurrence Typing}

%TODO: to be clear about what to say in ch2

Supporting gradual typing requires having matching types for values and functions in the languages.
Most extensions we have discussed have concepts of classes and objects, they are typed either
structurally or nominally.
However, instead of using classes or objects like other languages do,
typical Scheme programs prefers using composed data structures as simple as just pairs, vectors
and they are distinguished through testing the shape of the value or symbol comparison.
To solve this potential mismatch between values and types, occurrence typing is introduced.
The idea is that the difference occurrences of the same variable would have different types
depending on the context where it occurs.
Types are defined by specifying some boolean-returning unary functions as type discriminators.
When such a function \texttt{p?} in question returns non-falsy value for a value \texttt{v},
the type system will consider \texttt{v} to have value \texttt{p}.
This way, a \texttt{if}-expression that depends of value of \texttt{(p? v)},
will have its two branches with different types of \texttt{v}, one with type \texttt{p}
and another with non-\texttt{p} type.

\subsection{Parametric Polymorphism}

\section{Dealing with Structural Data}

Practical languages come with support for structural data in which multiple values
can be combined together to construct one single value, which is usually called an object.
These values can be retrieved later using a key or index into that object.
Imperative languages would even allow values in an object to be removed or updated at runtime,
which complicates some support towards gradual typing.
It is such an important concept that all languages we have discussed so far study
it to some extent.

% The notion can also be extended to object-oriented programming,
% in which structural data are just objects with only fields and objects are also
% allowed to have methods who can either share methods from other objects,
% or defines it own to allow different runtime behavior.

\subsection{Structural Data and Subtyping}

\subsection{Differential Subtyping}

The purpose of combining static and dynamic typing is to reduce
runtime checks when checks could have been performed once ahead of execution.
Differential subtyping by Safe Typing takes this idea and apply it in a finer-grained level.

\subsection{Support Field Mutation}

\subsection{Object-Oriented Programming}

The idea of structural data goes further: object-oriented programming adds methods to objects,
and them to be shared by inheritance.
This increase flexibility as different runtime behavior are enabled even if method of the same name and type signature is called.

\subsubsection{Nominal or Structural}

Structural type can be useful for languages that uses the practice of duck typing, as only the shape of types are required to be checked.
However, nominal types can also find its uses when it comes to object-oriented programming,
as structural type does not account for inheritance that object-oriented programming relies heavily on.

\subsubsection{Self Types}

\subsection{Recursive Data Types}

\section{Eval function}

\section{Other Performance Concerns}

\subsection{Large Arrays}

For programs that need runtime typechecks on large arrays,
the overhead could be wasteful but significant.

\subsection{Type Erasure}

\section{Language-specific Challenges}

\subsection{TypeScript}

\subsection{Typed Scheme and Macros}

\subsection{Python}

\subsection{Gradualtalk and Live system}

\subsection{$\csharp$ 4.0}

%Chapter 4
\renewcommand{\thechapter}{4}
\chapter{Related Work}

% (TODO) sound gradual typing is nominally alive and well

TypeScript implements "occurrence typing" (see "Type Guards and Differentiating Types" of advanced types) and Array as tuple 
%\renewcommand{\thechapter}{5}

%\chapter{Future Work}

\renewcommand{\thechapter}{5}
\chapter{Conclusion}