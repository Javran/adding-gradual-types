%Chapter 2

\renewcommand{\thechapter}{2}

\chapter{Extending existing languages}

Gradual type system features optional type annotations,
which is compatible with both statically and dynamically typed programs,
type safety are preserved and semantics are kept consistent.
This makes it an ideal type system that
existing languages can be extended to support.

In this chapter, we will explore some research works that extends existing languages
to support gradual typing. As we will see, this is not a trivial task:
since it requires the extended language to still support existing programs written
in the original language with little to none modification,
language features, idiom and practice commonly used among its community
needs to be carefully understood to allow a smooth and non-intrusive experience.

\section{From JavaScript to TypeScript}

Starting as a scripting language, JavaScript has grown into a language
that powers many large web applications.
Unfortunately, as a language that exists over a long period of time,
the language evolves but many of its flaws are still left as it is for compatibility reasons,
hindering productivity of many programmers.

Among tools and extensions to JavaScript that attempt to ease this pain,
TypeScript is one closely related to gradual typing:
it is a superset of JavaScript that supports optional type annotations,
a compiler typechecks TypeScript code ahead of execution and compile code
into plain JavaScript source code, making it ready to be executed out of box
for JavaScript engines.
However, TypeScript is intentionally unsound: only static typechecking is performed,
which does not prevent runtime type errors.
One noticeable improvement to TypeScript is Safe TypeScript by Rastogi, Swamy, Fournet, Bierman \& Vekris, which shares the same syntax with TypeScript
but features a sound type system and efficient runtime type information(RTTI)-based
gradual typing.

\subsection{Type Checking for Free}

In JavaScript, one cannot declare a variables to have a specific type,
which often leads to the style in which function checks its argument type at runtime
before proceeding with actual implementation:

\begin{verbatim}
function f(x) {
    if (typeof x !== 'string') {
        // throw error
    }
    return x + '!';
}
\end{verbatim}

By extending the language with an optional type annotation,
the code is improved to have less verbosity in Safe TypeScript: 

\begin{verbatim}
function f(x : string) {
    return x + '!';
}
\end{verbatim}

Here the logic for checking whether $x$ is a string is removed,
instead, Safe TypeScript compiles it to insert code for type checking,
and throws with error messages upon failure.

By introducing type annotations, programmers get not just dynamic type checking without
much effort, but also enables static type checking. Consider the following code with $f$
above in scope:

\begin{verbatim}
f('one'); // good
f(1); // bad
\end{verbatim}

While manual type checking in function bodies throws when the bad call is invoked,
Safe TypeScript is capable of capturing the error ahead of execution.

\subsection{Nominal class and structural interfaces}

NOTES

(probably showcasing)

Object as map

Object in the sense of OOP

\subsection{Type-safety and encapsulation}

\subsection{RTTI and Performance}


\section{From Scheme to Typed Scheme}



\begin{verbatim}
(define (creal x)
  (cond [(number? x) x]
        [else (car x)]))
\end{verbatim}

occurrence typing

simple macros?

\section{Reticulated Python}


structural typing to match for Python's duck typing

CSharp (this being the only static language that wants interaction with dynamic ones)

syntactic improvement
dynamic Object ("Expando Object")

\section{C$^\sharp$ 4.0}


\section{Gradualtalk}

TODO