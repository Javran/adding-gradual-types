%Chapter 3

\renewcommand{\thechapter}{3}

\chapter{The Way Towards Gradual Typing}

Previous chapter explored the benefits gradual typing
can bring in for existing languages.
This chapter discuss the way towards making the extension:
common and language-specific challenges the researchers have faced,
and their solutions.

\section{Extensions to Type Systems}

Gradual type system supports both fully static and fully dynamic typing,
which requires support for traditional static types including
basic type, function type and types for structural data
and a notion of dynamic type to allow presence of partial type information
in the system. And static typechecking and runtime checks should work together
to establish soundness for the extended languages.

In addition to this, interesting extensions have been made
for several languages we have discussed so far to provide better gradual
typing support.

\subsection{Extension for Dynamic Languages}

The common approach for dynamic languages to make the extension
is to first perform static typechecking in the presence of dynamic types,
then if it is successful, translate programs into original language.
This ensures maximum compatibility with original language, and
the implementation should work across different implementations of the same language.

Safe TypeScript is implemented as a pass of TypeScript compiler,
which does static typechecking to further detect potential errors,
and type casts are inserted to several locations. These casts are calls
to Safe TypeScript runtime that performs typechecking logic and maintains
potential runtime type information on its own.

Reticulated Python is implemented as a source-to-source compiler
in Python 3. Runtime casts are translated into calls to an external library
that authors have developed.

Gradualtalk is an extension to Pharo Smalltalk. It consists of 3 parts:
the core allows representing types in Smalltalk, the typechecker
is responsible of performing static typechecks and finally
a type dictionary for storing type information.

Typed Scheme takes a similar approach: the implementation is a macro
(a source-to-source transformer) that does typechecking and expands source code.
This phase either results in static type error being reported,
or a working source code in PLT Scheme ready for execution.

\subsection{Differential Typing}

The purpose of combining static and dynamic typing is to reduce
runtime checks when checks could have been performed once ahead of execution.

\subsection{Occurrence Typing}

For a language that makes heavy use of control flow to dispatch actions,
occurrence typing looks nature.

\subsection{Bidirectional Typing}

A carefully implemented 2-phase typechecking preserves transitivity of subtyping.

\section{Dealing with Structural Data}

Structural data combines data types together to form organized data for processing.
It is such an important concept that all languages we have discussed so far study
it to some extent. The notion can also be extended to object-oriented programming,
in which structural data are just objects with only fields and objects are also
allowed to have methods who can either share methods from other objects,
or defines it own to allow different runtime behavior.

\subsection{Structural Data and Subtyping}

\subsection{Object-Oriented Programming}

\subsection{Nominal or Structural}

\subsection{Recursive Data Types}

using predicates
constraints as type level computation (requires a type system of sufficient expressiveness)

typing structural data

nominal
- structural

object identity

giving `this` / `self` special type treatment

inheritance (could merge with subtyping)

variable / member mutation

\section{Other Performance Concerns}

cast insertion

Large array

runtime check overhead

\section{Language-specific Challenges}

%Chapter 4
\renewcommand{\thechapter}{4}
\chapter{Related Work}

(TODO) sound gradual typing is nominally alive and well


TypeScript implements "occurrence typing" (see "Type Guards and Differentiating Types" of advanced types) and Array as tuple 
\renewcommand{\thechapter}{5}

\chapter{Future Work}

\renewcommand{\thechapter}{6}
\chapter{Conclusion}