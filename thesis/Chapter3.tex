%Chapter 3

\renewcommand{\thechapter}{3}

\chapter{The Way Towards Gradual Typing}

Previous chapter explored the benefits gradual typing
can bring in for existing languages.
This chapter discuss the way towards making the extension:
common and language-specific challenges the researchers have faced,
and their solutions.

\section{Extensions to Type Systems}

Gradual type system supports both fully static and fully dynamic typing,
which requires support for traditional static types including
basic type, function type and types for structural data
and a notion of dynamic type to allow presence of partial type information
in the system. And static typechecking and runtime checks should work together
to establish soundness for the extended languages.

In addition to this, interesting extensions have been made
for several languages we have discussed so far to provide better gradual
typing support.

\subsection{Extension from Dynamic Languages}

The common approach for dynamic languages to make the extension
is to first perform static typechecking in the presence of dynamic types,
then if it is successful, translate programs into original language.
This ensures maximum compatibility with original language, and
the implementation should work across different implementations of the same language.

Safe TypeScript is implemented as a compiler pass of TypeScript,
which does static typechecking to further detect potential errors,
and type casts are inserted to several locations. These casts are calls
to Safe TypeScript runtime that performs typechecking logic and maintains
potential runtime type information on its own.

Reticulated Python is implemented as a source-to-source compiler
in Python 3. Runtime casts are translated into calls to an external library
that authors have developed.

Gradualtalk is an extension to Pharo Smalltalk. It consists of 3 parts:
the core allows representing types in Smalltalk, the typechecker
is responsible of performing static typechecks and finally
a type dictionary for storing type information.

Typed Scheme takes a similar approach: the implementation is a macro
(a source-to-source transformer) that does typechecking and expands source code.
This phase either results in static type error being reported,
or a working source code in PLT Scheme ready for execution.

\subsection{Extension from A Bidirectional Type System}

\subsection{Union Types}

Practical languages utilize control flows to have different behaviors for different situations.
For a dynamic language, an expression can usually return values of various possible types.
While simply assigning $\dyn$ as the type of the whole expression will work,
it is less useful as type information is lost in the process.
The solution is to represent the sum of these types.

% TODO

\subsection{Occurrence Typing}

%TODO: to be clear about what to say in ch2

Supporting gradual typing requires having matching types for values and functions in the languages.
Most extensions we have discussed have concepts of classes and objects, they are typed either
structurally or nominally.
However, instead of using classes or objects like other languages do,
typical Scheme programs prefers using composed data structures as simple as just pairs, vectors
and they are distinguished through testing the shape of the value or
symbol comparison.
To solve this potential mismatch between values and types, occurrence typing is introduced.
The idea is that the difference occurrence of the same variable would have different types
depending on the context where it occurs.
Types are defined by specifying some boolean-returning unary functions as type discriminators.
When such a function \texttt{p?} in question returns non-falsy value for a value \texttt{v},
the type system will consider \texttt{v} to have value \texttt{p}.
This way, a \texttt{if}-expression that depends of value of \texttt{(p? v)},
will have its two branches with different types of \texttt{v}, one with type \texttt{p}
and another with non-\texttt{p} type.

\section{Dealing with Structural Data}

Structural data combines data types together to form organized data for processing.
It is such an important concept that all languages we have discussed so far study
it to some extent. The notion can also be extended to object-oriented programming,
in which structural data are just objects with only fields and objects are also
allowed to have methods who can either share methods from other objects,
or defines it own to allow different runtime behavior.

\subsection{Structural Data and Subtyping}

\subsection{Differential Subtyping}

The purpose of combining static and dynamic typing is to reduce
runtime checks when checks could have been performed once ahead of execution.

\subsection{Object-Oriented Programming}

\subsection{Nominal or Structural}

\subsection{Recursive Data Types}

using predicates
constraints as type level computation (requires a type system of sufficient expressiveness)

typing structural data

nominal
- structural

object identity

giving `this` / `self` special type treatment

inheritance (could merge with subtyping)

variable / member mutation

\section{Other Performance Concerns}

cast insertion

Large array

runtime check overhead

\section{Language-specific Challenges}

%Chapter 4
\renewcommand{\thechapter}{4}
\chapter{Related Work}

(TODO) sound gradual typing is nominally alive and well


TypeScript implements "occurrence typing" (see "Type Guards and Differentiating Types" of advanced types) and Array as tuple 
\renewcommand{\thechapter}{5}

\chapter{Future Work}

\renewcommand{\thechapter}{6}
\chapter{Conclusion}