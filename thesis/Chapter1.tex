%Chapter 1

\renewcommand{\thechapter}{1}

\chapter{Introduction}

Type system defines sets of rules about programs, which can be checked by a machine
in a systematic way.
One can assign types to appropriate language concepts like
variables, functions and classes to describe expected behaviors
and how they interact with each other.
Then type system takes the responsibility of ensuring that types are respected and
type errors prevent erroneous part of a program from execution.

There are other benefits of type systems besides automated checking:
types can be used to reveal optimization opportunities,
can serve as simple documentation to programmers or
provide hints to development tools to automate navigation, documentation lookup
or auto-completion.

All these benefits make type system an important part of programming languages,
and there are different ways of accommodating languages with type systems.
The most noticeable difference is the process of checking programs again type rules,
which is also known as type checking.
It occurs either statically ahead of program execution, or dynamically at runtime.
For a static type system, ill-typed programs are rejected by compiler and
no executable can be produced until all type errors are fixed.
For a dynamic type system, type information is examined at runtime and type errors result
in abortion of the program or exceptions being raised
instead of causing segmentation faults or other worse consequences.
Static and dynamic type system both have their advantages and disadvantages,
and languages make different choices depending on their needs.

In this chapter, we start off by discussing static and dynamic type systems,
which motivates research works that attempted to combine both within one system
in order to take the benefits from the two,
which in return gives birth to many possible solutions.
One particular example among them is gradual typing.

\section{Strengths and Weaknesses of Static and Dynamic Typing}

The difference between static and dynamic typing is the difference
between whether type checking occurs ahead of execution or at runtime.
This section discusses advantages and disadvantages of both.

\newcommand{\tnum}{\textbf{num}}
\newcommand{\tstr}{\textbf{str}}
\newcommand{\tbool}{\textbf{bool}}
\newcommand{\tarr}[2]{#1 \rightarrow #2}

In this section we use $\tau_0, \tau_1, \ldots$ for type variables.
$\tbool$, $\tnum$ and $\tstr$ are types of
boolean values, numbers and strings respectively.\
Tuple types are notated as $(\tau_0, \tau_1, \ldots)$,
and the type notation for functions that takes as input a value of type $\tau_0$
and returns a value of $\tau_1$ is $\tarr{\tau_0}{\tau_1}$.
We use $o : \tau$ to mean that a term $o$ is assigned type $\tau$.
For example $f : \tarr{(\tnum, \tnum)}{\tnum}$ is a function that
takes a tuple of two numbers as input and returns a number.

\subsection{Static Type Systems}

%TODO: type system or language?

A static type system is preferred if robustness and performance
is the main goal of a language.
Because type checking occurs ahead of execution,
ill-typed programs are rejected before it can start, and
when a program typechecks,
one can therefore expect no type error to occur and
no extra cost is paid for typechecking at runtime.

For a static type system to work, all variables, functions, etc. in a program
will need to be assigned types. This is usually done by programmers or through the
means of type inference, which is a technique that infers types using
available type information. This is both an advantage and a disadvantage
of a static type system: having type annotations improves readability
and since programmers are required to keep the consistency between type and code,
type also serves as simple, faithful documentation. But on the other hand,
adding and maintaining type annotations can also considered a burden.

Having static known type information also helps in terms of performance in other ways.
For example, In many programming languages, arithmetic functions are polymorphic.
It is allowed for \textbf{a} and \textbf{b} to have different numeric types in \textbf{a + b}, a cast will be inserted to ensure arithmetic primitives only deals with addition of compatible types: if we are adding integer \textbf{b} to a floating number \textbf{a}, then \textbf{b} will be casted so we can call addition primitive that expected floating numbers on both sides.
A dynamic language would have to figure out types of \textbf{a} and \textbf{b} at runtime, make decision about whether casting is required or which primitive addition to call all at runtime. But with type information statically available,
these decisions can be made ahead of execution,
resulting in improved performance at runtime.

Besides extra effort of maintaining type annotations,
the disadvantage of a statically type language often lies in the lack of runtime flexibility.
If we want to write a program that deals with data whose structure is
unknown at compile time, runtime inspection must be possible.
While typical dynamically typed languages allow inspect of types or object properties,
some extra work are required for a statically typed language
to keep type information available at runtime.

In addition, it is often less convenient for programmers to prototype
in statically typed languages: it involves trial and error to find the best implementation
to solve a problem, which means the ability to write partial programs,
make frequent changes to structure of variables and functions, but these features are not easily available for a statically typed language.

\subsection{Dynamic Type Systems}

Dynamic type systems do typechecking at runtime, which is best suited for
languages designed for scripting and fast prototyping.
A shell script, for example, runs other executables and feeds one's output to another, effectively gluing programs together.
In such a case, we have little to no knowledge about these executables ahead of time,
making statically type checking impractical.
And when it comes to prototyping,
it is more important for programmers to execute the code and make modifications accordingly
than to enforce correctness and consistency through whole program.
In such scenario, it is more convenient to delay type checking until
it is required at runtime.

However, it is also easy to spot weaknesses of dynamic type systems.
Despite that type checking does not happen ahead of execution,
programmers usually have facts about behaviors of programs,
which is often described in comments or through naming of variables and functions without a systematic way of verifying them.
As program develops, it is easy to make changes and forget updating these descriptions accordingly, which forces future maintainers to go back and rediscover these facts, causing maintenance difficulties.

%TODO: throw error at runtime

Furthermore, without type information statically available,
dynamic type system needs to maintain runtime information
and rely on it to implement expected semantics.
For example, if it is allowed for a language to condition on non-boolean values,
its type has to be available at runtime in order to
determine how to cast it into a boolean value at runtime.

Optimization could also be hindered for a dynamically type language: 
array cloning can be implemented efficiently as memory copy instructions knowing the array in question contains only primitive values but no reference or pointers, whereas without prior knowledge like this, every element of the array has to be traversed and even recursively cloned.


\section{Combining the benefits of the two}

%TODO could have more to say.

One might have noticed that static type checking and dynamic one
are not mutually exclusive: it is possible to have a program typechecked
statically, while allowing runtime type checking.
While static type system does typechecking ahead of time
and avoids runtime overhead,
it lacks the ability of using runtime type information;
dynamic type system does typechecking at runtime,
but it requires sophisticated work to reduce the amount of
unnecessarily repeated runtime checks.
In hope of bringing in benefits of both,
several attempts are motivated to put these two type systems in one.
In this section, we will discuss about these research works.

\subsection{Design Goals}


Summarizing pros and cons of static and dynamic typed languages,
we now have a picture of an ideal type system, it should have following features:

\begin{itemize}
	\item \textbf{Detect and rule out errors ahead of program execution.} This is one main purpose of having a static type system. When a program starts running,
	type errors should already be eliminated and runtime overhead should be minimized
	to keep its performance close to that of a static type system.
	\item \textbf{Delay typechecking until needed at runtime.}
	This is the crucial feature of a dynamic type system,
	it allows ill-typed or partially written programs to execute,
	which makes it suitable in situations where static type information
	is limited or fast prototyping is preferred over robustness or runtime performance.
\end{itemize}

Aside from these two goals, type annotations can also be used for
other purposes like optimization and providing hints to development tools.
For a language with this new type system, it should also be possible.

\subsection{A Introduction to Gradual Typing}

\newcommand{\dyn}{\textbf{dyn}}

Gradual typing is one possible approach that meets our design goal.
It captures the fact that type information might only be partially known
ahead of execution by introducing a special type that indicates partial types.
It attempts to typecheck programs like a static type system does, but delays
typechecking on partial types until sufficient type information is available
at runtime.

In the following sections, we will introduce it
as an extension to static type system.
But it is also possible and practical to support gradual typing by
extending a dynamic type system.

% TODO: in fact maj of langs are extended from dynamic ones

\subsubsection{Dynamic Type and Type Consistency}

Gradual type system introduces a special type on top of a static type system
to capture the idea that type information might only be partially known
ahead of execution.
The special type is usually called a ``dynamic type'', we introduce a special type $\dyn$ for it.

To deal with dynamic types, type consistency is introduced
to accommodate type judgments for gradual typing.
Figure ? shows rules for type consistency relation.

(TODO: type consistency rules here, lambda calculus and with some ground types)

In general, two types are consistent when
their type structures do not conflict with each other.
For example, $\tbool$ is consistent with type $\dyn$
despite that the latter is less precise;
$\tarr{\tnum}{\dyn}$ is consistent with both $\tarr{\dyn}{\tnum}$ and $\tarr{\dyn}{\dyn}$,
because all these types are functions that accepts one value and returns another and
$\tnum$ and $\dyn$ are consistent with each other.
However $\tarr{\dyn}{\dyn}$ is never consistent with $\tbool$,
because the former is a function type while the latter a boolean value,
whose type structures do not match.

In order to perform static typechecking, it is required that
all terms in the program to must have types ahead of execution.
In a gradual type system, this is no longer required:
for a specific term,
if programmers choose not to give a type annotation, it will be assigned type $\dyn$.
This still allows static typechecking to detect errors because
for types that contains $\dyn$, it is not totally ignored, but checked
up to the point where the structure of type is known.

On the other hand, a dynamically type program can now be statically typechecked
by considering it to be a program without any type annotation.
This is still beneficial, as some literal values and primitives will still have their built-in types,
an obvious misuse like taking the square root of a string value can now be detected ahead of execution
instead of raising runtime exceptions.

\subsubsection{Cast Insertion and Runtime Typechecking}

As we can see gradual type system attempts to contain both statically and dynamically typed programs.
However, because of presence of dynamic types,
the type system cannot be sound by only have static typechecking.
Imagine function $f : \tarr{\tnum}{\dyn}$ and variable $v : \dyn$, while the function application
$f v$ can pass static typechecking, the runtime value of $t$ might turn out to be a string
and now the application is ill-typed.

The problem lies in the fact that some terms might be assigned with types that contains
$\dyn$, its runtime counterpart are precise, which is not checked during static typechecking.
To solve this problem, casts are inserted at appropriate locations, which then
allows type errors to be detected at runtime.
Suppose we have a cast function $c : \tarr{\dyn}{\tnum}$, function application $f v$
then becomes $f (c v)$, which still typechecks, but whenever we need to pass a runtime value to $f$,
its runtime is always checked by $c$ to decide whether to pass the value to $f$ or raise
a type error.
%TODO: from Gradual Typing for Functional Languages

\subsubsection{Optional Type Annotation and ``pay-as-you-go''}

So far we have seen that gradual type system introduces a dynamic type,
which allows accepting both statically and dynamically typed programs during static typechecking.
But what is more important is that it creates a middle ground in which programs
can be partially annotated with types:
in a gradual type system, terms are either explicitly given a type,
or, when type annotation is missing, given $\dyn$ type.
This renders all type annotations to be optional and allows programmers
to have more control over what they need from typechecking:
for an originally statically typed program, we can now write terms without giving a type,
this allows easy prototyping; for an originally dynamically typed program,
some parts of it might already been stable and robust enough, annotating these parts
with type allows some effort of ensuring correctness being shifted to typechecking.

For example, one might wish to implement a function $f$ that expects a string value
as input. There are two approaches: we can either give $f$ a type annotation:
$f : \tarr{\textbf{str}}{\dyn}$. By doing so, type system takes the responsibility
of making sure that the input type is indeed a string. Alternatively,
we can inspect type of the input value at runtime ourselves.
A static type system allows us to do the former, but a return type must either
be given explicitly or inferred. And a dynamic type system does the later, but
we cannot statically detect any mistake like applying a number literal to $f$.
However, a gradual type system finds the balance between two,
it allows us to give input value a type without worrying about
giving a return type if not needed,
therefore programmer only pays for what they want from a type system.

%TODO more to say



\subsubsection{Gradual Guarantee}

Regarding the term gradual typing itself,
Siek, Vitousek, Cimini and Boyland's work gives a detailed explanation of
the original intention.
Several works we are going to discuss in the following few chapters respects
such idea:

\begin{itemize}
	\item Gradual typing includes both fully static and fully dynamic
	\item Gradual typing provides sound interoperability
	\item Gradual typing enables gradual evolution
\end{itemize}


\subsection{Alternatives}

There are other type systems that bring benefits of the two together.
Cartwright and Fagan's introduced soft typing, which is a type system
that programers do not write type annotations but use type inference to
assign appropriate types to terms, and runtime checks are inserted as needed.
The drawback of this design is that programmers do not have control over types.
%TODO probably more drawbacks
Quasi-static typing is another attempt, with the idea of dynamic type in use,
it chooses to use a subtyping relation and allows both up-casts and down-casts.
A second pass of plausibility checking detects incompatible casts and signals the program
in question as ill-typed. However its typechecking algorithm did not receive a correct proof,
and it does not statically catch all type errors (TODO: ref)
in the process of attempting the proof, Siek and Taha finds a better solution, 
which results in gradual typing that we have seen today.
%TODO? 

\subsection{Discussion}

Among various research works that combines
benefit of static and dynamic type checking
gradual typing remains one of the most popular approach.
In the sprite of gradual guarantee, gradual typing extensions aim at
making all existing programs written in the original one still valid with little difference in semantics.
In addition, unlike other approaches, programmers have better control over should and should not be typechecked.

Despite that gradual type systems are well-studied research topics,
extending existing languages to support them is far from trivial task.
To name few differences, while theoretical type systems assume primitive types as simple as just numbers and booleans,
a practical language have various kinds of them including integers, floating numbers, strings and arrays,
which have not been addressed much.
In addition, language-specific features, idioms and common practice needs
to be carefully studied to allow existing code and language users to transit smoothly into
the extended language. In this survey we will explore literatures that extends existing languages to support gradual typing.
In chapter 2, we will focus on benefits of making these extensions. Chapter 3 discusses and categorizes common and language-specific
challenges researchers have to face and solutions to them.
Some of these challenges, however, still remains as open questions, which will be covered in chapter 4.

