%Section 2

\section{Benefits of Gradual Typing}

Besides most advantages one could expect from static and dynamic typing,
the synergy also creates surprising new benefits to languages users.

In this section, we will explore some literatures
from aspects of language users
and see in detail about these benefits that gradual typing have brought in.

\subsection{From JavaScript to Safe TypeScript}

Starting as a scripting language, JavaScript has grown into a language
that powers many large web applications.
Unfortunately, as a language that exists over a long period of time,
the language evolves but many of its flaws are still left as it is for compatibility reasons,
hindering productivity of even most experienced programmers.

Among tools and extensions to JavaScript that attempt to ease this pain,
TypeScript is one closely related to gradual typing.
Its syntax is a superset of JavaScript that supports optional type annotations on variables.
A compiler typechecks TypeScript source code ahead of execution
and compile it into plain JavaScript source code,
making it ready to be executed out of box for JavaScript interpreters.

However, TypeScript is designed to typecheck programs only
statically, remove all traces of type and emit JavaScript code with no extra runtime overhead.
Since we cannot enforce invariants at runtime, TypeScript is intentionally unsound
and benefits from the type system is therefore limited.

Nonetheless, TypeScript still serves as a reasonable starting point
for Safe TypeScript by Rastogi, Swamy, Fournet, Bierman \& Vekris \cite{rastogi2015safe}.
Safe TypeScript shares the same syntax with TypeScript,
but features a sound type system and efficient runtime type information (RTTI)-based
gradual typing.

In this section we will visit some language features of Safe TypeScript and see how it improves JavaScript. Note that TypeScript uses $\texttt{any}$ for dynamic type.

\subsubsection{Type Checking for Free}

Despite JavaScript is capable of examining type of values at runtime,
it does not have support for type annotations.
This leads to a common practice in which we have some lines of code
right after entering the body of a function
to check its argument types, report errors if any, before
proceeding with actual implementation:

\begin{minted}{javascript}
function f(x) {
    if (typeof x !== 'string') {
        // throw error
    }
    return x + '!';
}
\end{minted}
% TODO XXX

As a toy example, the function accepts a string value,
then returns another with exclamation sign concatenated to it. 
But imagine in real projects there will be multiple arguments to a function
and some of them have to go through this process of checking,
it will soon become less maintainable.

By extending the language with type annotations,
we can do something better in Safe TypeScript:

\begin{minted}{javascript}
function f(x : string) : string {
    // now this check becomes unnecessary
    if (typeof x !== 'string') {
        // throw error
    }
    return x + '!';
}
\end{minted}

In the code above, we just declared a function $\textbf{f}$ that accepts
one variable $x$ of $\textbf{string}$ type, and returns a value of $\textbf{string}$ type.
The code for runtime checking is removed, instead, Safe TypeScript performs typechecking
and insert casts when needed to ensure that,
when $\textbf{f}$ is called, its argument is indeed a $\textbf{string}$.
This renders the  $\textbf{typeof}$ check at the beginning useless:
when we enter the function body $\textbf{x}$ is guaranteed to be a $\textbf{string}$,
therefore the body of the $\textbf{if}$ statement cannot possibly be entered.
This allows us to get rid of the check totally:

\begin{minted}{javascript}
function f(x : string) : string {
    return x + '!';
}
\end{minted}

The use site of $\textbf{f}$ might look like the following:

\begin{minted}{javascript}
f('one'); // good
f(1); // bad
function g(x) {
    return f(x); // might be unsafe
}
\end{minted}

Here Safe TypeScript is able to tell that: calling $\textbf{f}$ with a string literal
is safe, and no extra cast is needed; the second call is immediately rejected
because number literal is clearly not a $\textbf{string}$;
and for the third case where $\textbf{x}$
is not explicitly given a type, Safe TypeScript compiler will insert runtime type cast
and either allow it to proceed to the body $\textbf{f}$ when $\textbf{x}$ is indeed a string,
or throw an error before even calling $\textbf{f}$.

Notice that by making use of type annotations, Safe TypeScript not only allows
clearer code, but also able to spot some type errors ahead of execution:
imagine the function application $\textbf{f(1)}$, when its written in plain JavaScript,
we have to wait for the check in function body to throw an error,
while annotating $\textbf{x}$ with a type allows Safe TypeScript
to spot the error even before execution.

%TODO: this generalized to many dynamic languages

\subsubsection{Object-Oriented Programming in Safe TypeScript}

%TODO: what technique allos JS to simulate OO?

JavaScript is a prototype-based language.
This means runtime objects form a chain in which one object
can be a prototype of other objects and
to perform method invocation, method names are searched
first in object itself and then along the chain,
and the first one with matching method name is used for the invocation.
Using well-known techniques allows JavaScript to simulate objected-oriented programming.
Designed to be a superset of JavaScript, Safe TypeScript must accommodate such programming
style as well.

TypeScript introduces the concept of interface to allow representing the structure
of runtime objects.

\begin{minted}{javascript}
interface Point { x: number; y: number }
\end{minted}

This defines $\textbf{Point}$ type to be an object that has two fields $\textbf{x}$
and $\textbf{y}$ whose types are all $\textbf{number}$s.
For example, the invocation with object literal $f(\textbf{\{x: 1, y: 0\})}$ typechecks
with $f : Point \Rightarrow any$.
An interface can be implemented by classes:

\begin{minted}{javascript}
class MovablePoint implements Point {
  constructor(public x: number, public y: number) {this.x = x; this.y = y;}
  public move(dx: number, dy: number} { this.x += dx; this.y += dy; }
}
\end{minted}

While in TypeScript, all classes are viewed structurally, this does not match
with JavaScript semantics. Consider the following function:

\begin{minted}{javascript}
function mustBeTrue(x : MovablePoint) {
  return !x || x instanceof MovablePoint;
}
\end{minted}

One might expect this function to always return $\textbf{true}$.
However, a structural view will consider object literal
$v$ = \textbf{\{x: 0, y: 0, move(dx: number, dy:number) {}\}}
to match with $\textbf{MovablePoint}$, but $\textbf{mustBeTrue(v)}$
will return $\textbf{false}$ because JavaScript will expect $v$ to have
$\textbf{MovablePoint}$ somewhere along its prototype chain.

To solve this problem, Safe TypeScript takes a different approach:
it treats class types nominally but can be viewed structurally.
Namely, $\textbf{MovablePoint}$ is still a subtype of
$t_m$ = \textbf{\{x: number, y: number, move(dx: number, dy:number): any\}}
and \textbf{\{x: number, y: number\}}.
But $t_m$ is no longer a subtype of \textbf{MovablePoint}.

%TODO: method & field

%TODO: put this in ch3 \subsection{Type Erasure, information hiding and performance}

%TODO: "this"


\subsection{From Scheme to Typed Scheme}

Scheme is a dynamically typed language.
It is used for casual scripting as well as industrial applications.
Like other dynamic typed languages, programmers are not attached to using any
type discipline but rely on various kind of reasoning on their needs.
This makes the language flexible but challenging to assign proper and precise types to terms.

Tobin-Hochstadt and Felleisen's work on Typed Scheme
introduces the notion of occurrence typing, which
extends Scheme with gradual typing.

%TODO: type discipline vs type system?

\subsubsection{Support Informal Reasoning}

The following code shows a function definition as typical style of programming in this language:

\begin{minted}{scheme}
;; a Complex is either
;; - a number
;; - (cons number number)
(define (creal x)
  (cond [(number? x) x]
        [else (car x)]))
\end{minted}

The code above defines a function $\textbf{creal}$, which takes as argument
a complex number: a real number is simply a value satisfying $\textbf{number?}$,
while an imaginary number is a pair of $\textbf{number}$.
Function $\textbf{number?}$ distinguishes two different representation of numbers:
in the the first branch of $\textbf{cond}$, $\textbf{x}$ is treated like a number
while in the second branch $\textbf{x}$ is a pair and $\textbf{car}$ is used
to extract its real part.

One might have noticed that
while input value \textbf{x} could be either a number or a pair of numbers,
predicate \textbf{number?} distinguishes between them and
in difference branches of the \textbf{cond} expression, \textbf{x} gets different types.

It is important that type system should be able to assign same variable with different
types depending on the context where variable occurs, this is exactly the notion of
occurrence typing.

The Typed Scheme version begins with definition of complex number:

\begin{minted}{scheme}
;; a Complex is either
;; - a number
;; - (cons number number)
(define-type-alias Cplx (Union Number (cons Number Number)))
\end{minted}

While \textbf{Cplx} is just an alias for the union type, it improves readability
and allows other parts of the program to refer to it by name.
The body of the function looks like:

\begin{minted}{scheme}
(define: (creal [x: Cplx]) : Number
  (cond [(number? x) x]
        [else (car x)]))
\end{minted}

Note that we are explicitly giving the return type \textbf{Number},
and the type system is capable of inferencing that
both branch of \textbf{cond} expression returns a number
so it will still typecheck.

Another different kind of reasoning is also being used among Scheme programmers:
Suppose we have stored a list of various types of values in \textbf{xs}
and the following code will compute the sum of all numbers from \textbf{xs}:

\begin{minted}{scheme}
(foldl + 0 (filter number? xs))
\end{minted}

Note that despite \textbf{xs} is a list that contains not just numbers,
it is guaranteed that \textbf{(filter number? xs)} will return a list of numbers
so \textbf{foldl} will work properly to produce the desired result.

The expression requires no modification at all to typecheck in Typed Scheme
and it receives type system benefits: suppose \textbf{map} is mistakenly
used instead of \textbf{filter} or \textbf{number?} is replaced by
other predicates insufficient to test whether a value in question is indeed a value,
the type system is able to recognize such errors and give warnings.

\subsubsection{Refinement Type}

Note that in Scheme, we use \textbf{number?} to distinguish numbers
from other type of values.
In general, given a boolean-valued unary function
we can define the set of values that produces \textbf{true} when fed to this function.
This allows Typed Scheme to support refinement type.

\begin{minted}{scheme}
(: just-even (Number -> (Refinement even?)))
(define (just-even n)
  (if (even? n) n (error 'not-even)))
\end{minted}

The code above uses boolean-valued function \textbf{even?}
and its corresponding refinement type \textbf{Refinement even?},
so we can expect a value of such type to be not just numbers, but also only even ones.

More practical examples include use refinement types to distinguish raw input
from validated ones:

\begin{minted}{scheme}
(: sql-safe? (String -> Boolean))
(define (sql-safe? s) ...)
(declare-refinement sql-safe?)
\end{minted}

In this example, user defines function \textbf{sql-safe?} to verify
that a raw string contains no SQL injection or other contents of malicious attempt.
Then a refinement type is declared using this very function.
This makes available type \textbf{(Refinement sql-safe?)} to rest part of the program
to avoid mistakenly using raw input rather than verified safe ones.

As we can see occurrence typing not just enables
gradual typing, but also allows refinement type,
which provides us a powerful tool to use user-defined functions
to define custom types of better precision.

\subsection{From Python 3 to Reticulated Python}

Python 3 (Python for short) is another popular dynamic typed language.
M. Vitousek, M. Kent and Baker's work on Reticulated Python (Reticulated for short)
explored extending Python with gradual typing.

Python comes with annotation syntax.
This syntax allows expressions to be optionally attached to
function definitions and their arguments,
which makes it suitable for type annotation.

Given proper definition of \textbf{Int}, we can write annotated
function \textbf{distance} like below:

\begin{minted}{python}
def distance(x: Int, y: Int)-> Int:
  return abs(x - y)
\end{minted}

While annotation allows arbitrary expressions, Reticulated Python
only uses types built from several type constructors.

\subsubsection{Function Types}

Python 3 has different ways of calling the same function.
Suppose we want to use \textbf{distance} defined above,
we can use positional arguments like \textbf{distance(3,4)},
or use keywords like \textbf{distance(y=4, x=3)} and the result should be the same.

To support keyword calls, \textbf{Named} constructor is used to give
\textbf{distance} type \textbf{Function(Named(x: Int, y: Int), Int)}.
To support traditional positional arguments, \textbf{Pos} is used instead.
The type system also allows \textbf{Named} to be used as if it is constructed by \textbf{Pos}
when their length and element types correspond. So functions can be called in both
ways without problem. Additionally \textbf{Arb} is another constructor
that allows functions of arbitrary parameters.

\subsubsection{Class and Object Types}

Python is an object-oriented programming language.
Programmers define classes and create objects from them.
Both classes and objects are runtime values in Python
and Reticulated provides corresponding types for both.

Consider the following example:

\begin{minted}{python}
@fields({'x': Int})
class 1DPoint:
  def __init__(self: 1DPoint):
    self.x = 0
  def move(self: 1DPoint, x: Int)->1DPoint:
    self.x += x
    return self

p = 1DPoint()
\end{minted}

It defines a class \textbf{1DPoint} with one field \textbf{x} of \textbf{Int} type.
And an object is created from it through the constructor
and is bound to variable \textbf{p}.

Reticulated derives class type from this definition:

\begin{verbatim}
Class(1DPoint){
  move: Function(Named(self: 1DPoint, x: Int), 1DPoint)
}
\end{verbatim}

And object types are similar:

\begin{verbatim}
Object(1DPoint){
  move: Function(Named(x: Int), 1DPoint)
}
\end{verbatim}

While object can access methods of its class, it is also possible
to assign methods and fields to objects to change its behavior.
Therefore Reticulated makes object type open with respect to consistency.

\subsubsection{Dynamic Semantics}

Reticulated Python is not only a practical gradual type extension,
but serves as an experiment of exploring different dynamic semantics

\subsubsection{Other Features}

There are other features of Reticulate.
In particular, since it is not always possible to know what module would be loaded
at runtime, static typechecking sometimes occurs right after module is loaded.

Despite Python syntax supports annotation at function definition,
it does not provide a way of annotating local variables with tyoe.
Instead, Reticulated takes a step further and perform dataflow-based type inference.


\subsection{From Smalltalk to Gradualtalk}

Smalltalk is a language of highly dynamic nature:
it supports live programming, which means programs with incomplete
methods should be accepted, and programmers in Smalltalk relies on
idioms that are tricky to type properly.
Allende, Callau, Fabry, Tanter and Denker's work on Gradualtalk shows
us a well combination of various features in order to extend Smalltalk
into a gradual typed language.

\subsubsection{Annotating Programs with Types}

In Smalltalk there are objects that receives and processes messages.
The following example computes euclidean distance for points:

\begin{minted}{smalltalk}
Point >> distanceTo: p
| dx dy |
dx := self x - p x.
dy := self y - p y.
^ (dx squared + dy squared) sqrt
\end{minted}

Gradualtalk extends this syntax that allows
type annotation on parameter, return value and local variables.

\begin{verbatim}
Point >> (Number) distanceTo: (Point) p
| dx dy |
dx := self x - p x
dy := self y - p y
^ (dx squared + dy squared) sqrt
\end{verbatim}

Since local variable \textbf{dx} and \textbf{dy} does not explicit type-annotated,
they receive \textbf{Dyn} as default type.

Blocks are basic features in Smalltalk,
whose corresponding types are available in Gradualtalk in the form of normal function types.

\begin{verbatim}
Polygon >> (Number) perimeter: (Point Point -> Number) metricBlock
...
\end{verbatim}

This definition expects \textbf{metricBlock} to be block
that takes as argument two points, and returns a number.

\subsubsection{Self Types}

One practice in Smalltalk is to return object itself for setters
to allow chained calls:

\begin{verbatim}
Point >> (Point) y: (Number) aNumber
y := aNumber.
\end{verbatim}

Notice that if we want to extend this class in future,
its setter with be tagged with type \textbf{Point} and some
type information will be lost in the way.
To deal with this problem, Gradualtalk introduces self type:

\begin{verbatim}
Point >> (Self) y: (Number) aNumber
y := aNumber.
\end{verbatim}

If any other class inherits from it, the self type will make sure
to point to that class instead of sticking with \textbf{Point},
this allows type information to be preserved.

\subsubsection{Union Types}

Gradualtalk supports union types, which is useful when
source code contains different branches and each of them might return different types.

\begin{verbatim}
Boolean >> (a | b) ifTrue: (-> a) trueBlock ifFalse: (-> b) falseBlock
\end{verbatim}

Note that \textbf{trueBlock} and \textbf{falseBlock} might return
different types, allowing this method to have \texttt{a} or \texttt{b}
will not be satisfactory, and simply using \texttt{Dyn} type
returns in a lose of information.
Gradualtalk solves this problem by introducing union types: \texttt{a | b}
is a type by itself, which is compatible with both \texttt{a} and \texttt{b}.

\subsubsection{Structural and Nominal Types}

A structural type describes the shape of an object.

\begin{minted}{smalltalk}
RBParser >> bracketsOfNode: ({left (-> Integer) . right (->Integer)}) node
\end{minted}

The method above defines the argument type of \texttt{node} to have 2 methods:
\texttt{left} and \texttt{right} and both of them will return an integer when invoked.

A nominal type, on the other hand, is induced by classes
(for example an instance of \texttt{String} will have \texttt{String} type).
In addition, subtyping relations of them are formed from existing inheritance relation.

Gradual type managed to unify them in an interesting way.

\begin{minted}{smalltalk}
RBParser >> bracketsOfNode: (RBNode {
left (-> Integer) .
right (->Integer)
}) node
\end{minted}

Note that in addition to the structural type we have seen,
\texttt{RBNode} is a nominal type, the type of \texttt{node} above
limits the value to be not just an instance that understands certain methods,
but also requires it to be an instance of \texttt{RBNode}.

Another interesting example is the combination of structural type
and nominal type \texttt{Dyn}:

\begin{minted}{smalltalk}
Canvas >> (Self) drawPoint: (Dyn {x (-> Integer) . y (->Integer)}) point
... point x. "safe call"
... point y. "safe call"
... point z. "not an error, considering point to be Dyn"
\end{minted}

Besides calling \texttt{x} and \texttt{y}, a call to \texttt{z} does not
raise an error ahead of execution, because \texttt{Dyn} can be casted to allow use of
\texttt{z}.

\subsubsection{Type Aliases}

Gradualtalk supports type aliases. This does not expand expressiveness of type itself,
but it make reusing existing types convenient.

With type aliases comes the concepts of protocols, which are just type aliases
for structural and nominal types.

\newcommand{\csharp}{C^\sharp}
\subsection{From $\csharp 3.0$ to $\csharp$ 4.0}

While we have seen many examples that a dynamically typed language gets
gradual type extensions, Bierman, Meijer and Torgersen's work on
C$^\sharp$ 4.0 shows us a practical example of statically typed language
extends towards gradual typing.
This extension makes interoperation between statically and dynamically typed code
more convenient and brings in features meant for dynamically typed languages.

\subsubsection{Interaction with Dynamic Objects}

The following code snippet shows how C$^\sharp$ 3.0 interact with JavaScript:

\begin{minted}{csharp}
...
ScriptObject map = win.CreateInstance("VEMap", "myMap");
map.Invoke("LoadMap");
...
string latitude, longtitude;
...
var x = win.CreateInstance("VELatLong", latitude, longitude)
var pin = map.Invoke("AddPushpin", x);
pin.Invoke("SetTitle", name);
...
\end{minted}

In order to interact with JavaScript, method calls
are made using string-based interface, which is verbose, fragile to maintain.

With C$^\sharp$ 4.0, the source code can be simplified to:

\begin{verbatim}
...
dynamic map = win.CreateInstance("VEMap", "myMap");
map.LoadMap();
...
string latitude, longtitude;
...
var x = win.CreateInstance("VELatLong", latitude, longitude)
var pin = map.AddPushpin(x);
pin.SetTitle(name);
...
\end{verbatim}

Notice how types are changed to \textbf{dynamic} and methods are called
as if there are regular objects.
These improvements are more than just syntactic: gradual typing is implemented
so that typechecking can be involved and this part of code can benefit from it.

\subsubsection{Using Features Intended For Dynamic Languages}

The extension also makes available some features meant for dynamic languages
directly in C$^\sharp$, one example is the use of \textbf{ExpandoObject}

\begin{verbatim}
...
dynamic contact = new ExpandoObject();
contact.Name = "Erik"
contact.Address = new ExpandoObject();
contact.Address.State = "WA";
...
\end{verbatim}

For a statically typed language, to maintain structured object,
one either needs to declare a record type with matching structure,
or use a dictionary in which one key and one value type should be declared.
However, with the introduction of \textbf{ExpandoObject},
by simply assigning values to properties of it,
they are brought into existence without boilerplate about type casts.
This helps in terms of fast prototyping, in which programmers cares more about
having a working implementation than maintain type precision.

