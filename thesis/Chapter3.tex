%Chapter 3

\renewcommand{\thechapter}{3}

\chapter{The Way Towards Gradual Typing}

% TODO: could be organized better?

In previous chapter we have explored the benefits gradual typing
can bring in for existing languages.
There is no canonical way of supporting gradual typing:
it can be extended for either a static typed language or dynamically typed one,
and researchers have to make design choices depending on the nature of the language.
This chapter takes a step further to discuss the way towards making these extensions.
In general, this is not just an effort of putting theories of gradual typing into practical use,
but also introductions of new language features that accomplishes the changes
and helps development for these languages.

\section{Extensions to Type Systems}

Gradual type system supports both fully static and fully dynamic typing,
which requires support for traditional types including
basic type, function type and types for structural data
and a notion of dynamic type to allow presence of partial type information in the system.
Type soundness should be established by a combined work of static and dynamic typechecking.
Additionally, some other interesting extensions are also introduced to provide better
supports for gradual typing.

This section will separate these extensions into two categories:
\textbf{Essential extensions} are required for a complete gradual typing support;
and \textbf{complementary extensions} are those that improves type expressiveness
but a type system without them does not compromise completeness - after all,
explicit types are optional for gradual typing.

\subsection{Essential Extensions}

We are looking at research works that falls into two different type disciplines:
JavaScript, Scheme, Python 3 and Smalltalk are all dynamically typed languages.
And $\csharp$ 3.0 is statically typed language.
While dynamically typed languages share some similarity in their implementations.
The one from $\csharp$ 3.0 is quite a different story.

\subsubsection{Extension from Dynamically Typed Languages}

The common approach for dynamic languages to make the extension
is to first perform static typechecking in the presence of dynamic types.
If it is successful, programs written in extended languages are then translated into original languages.
The translated program could contain runtime checks, these checks are either implemented in place or
make calls to external libraries (which is usually called runtime in short) shipped with
the extended languages.

This ensures a high compatibility with original languages: source code written in extended language
can be compiled and then used as if it is written in the original language, and thanks to the fact
that all existing dynamically typed languages
we are discussing have decent supports for modern package managers,
including runtime support is as simple as making a dependency declaration to package metadata.
Besides, by compiling to the original languages,
we can ensure that the language implementations
 are independent of specific implementations of the original languages.

Safe TypeScript is implemented as a compiler pass of TypeScript.
In addition to the first pass that performs static typecheck and erases all type infomation
to produce code in JavaScript, it inserts a second pass that
does its own static typechecking to further detect potential errors,
and type casts are inserted to several locations instead of being completed removed.
These casts are calls to Safe TypeScript runtime that performs typechecking logic and maintains
potential runtime type information on its own.

Reticulated Python is implemented as a source-to-source compiler
in Python 3. Runtime casts are translated into calls to an external library
that authors have developed.

Gradualtalk is an extension to Pharo Smalltalk. It consists of 3 parts:
the core allows representing types in Smalltalk, the typechecker
is responsible of performing static typechecks and finally
a type dictionary for storing type information.

Typed Scheme takes a similar approach: the implementation is a macro
(a source-to-source transformer) that does typechecking and expands source code.
This phase either results in static type error being reported,
or a working source code in PLT Scheme ready for execution.

\subsection{Extension from A Bidirectional Type System}


\subsection{Complementary Extensions}

\subsubsection{Union Types}

Practical languages utilize control flows to have different behaviors for different situations.
For a dynamic language, an expression can usually return values of various possible types.
While simply assigning $\dyn$ as the type of the whole expression will work,
it is less useful as type information is lost in the process.
One solution that avoids making too much changes to programs is to introduce union types.

\subsubsection{Occurrence Typing}

%TODO: to be clear about what to say in ch2

Supporting gradual typing requires having matching types for values and functions in the languages.
Most extensions we have discussed have concepts of classes and objects, they are typed either
structurally or nominally.
However, instead of using classes or objects like other languages do,
typical Scheme programs prefers using composed data structures as simple as just pairs, vectors
and they are distinguished through testing the shape of the value or
symbol comparison.
To solve this potential mismatch between values and types, occurrence typing is introduced.
The idea is that the difference occurrence of the same variable would have different types
depending on the context where it occurs.
Types are defined by specifying some boolean-returning unary functions as type discriminators.
When such a function \texttt{p?} in question returns non-falsy value for a value \texttt{v},
the type system will consider \texttt{v} to have value \texttt{p}.
This way, a \texttt{if}-expression that depends of value of \texttt{(p? v)},
will have its two branches with different types of \texttt{v}, one with type \texttt{p}
and another with non-\texttt{p} type.

\section{Dealing with Structural Data}

Practical languages come with support for structural data in which multiple values
can be combined together to construct one single value, which is usually called an object.
These values can be retrieved later using a key or index into that object.
Imperative languages would even allow values in an object to be removed or updated at runtime,
which complicates some support towards gradual typing.
It is such an important concept that all languages we have discussed so far study
it to some extent.

% The notion can also be extended to object-oriented programming,
% in which structural data are just objects with only fields and objects are also
% allowed to have methods who can either share methods from other objects,
% or defines it own to allow different runtime behavior.

\subsection{Structural Data and Subtyping}

\subsection{Differential Subtyping}

The purpose of combining static and dynamic typing is to reduce
runtime checks when checks could have been performed once ahead of execution.
Differential subtyping by Safe Typing takes this idea and apply it in a finer-grained level.

\subsection{Object-Oriented Programming}

The idea of structural data goes further: object-oriented programming adds methods to objects,
and them to be shared by inheritance.
This increase flexibility as different runtime behavior are enabled even if method of the same name and type signature is called.

\subsection{Nominal or Structural}

Structural type can be useful for languages that uses the practice of duck typing, as only the shape of types are required to be checked.
However, nominal types can also find its uses when it comes to object-oriented programming,
as structural type does not account for inheritance that object-oriented programming relies heavily on.

\subsection{Recursive Data Types}

using predicates
constraints as type level computation (requires a type system of sufficient expressiveness)

typing structural data

nominal
- structural

object identity

giving `this` / `self` special type treatment

inheritance (could merge with subtyping)

variable / member mutation

\section{Other Performance Concerns}

\subsection{Large Arrays}

For programs that need runtime typechecks on large arrays,
the overhead could be wasteful but significant.

\section{Language-specific Challenges}

%Chapter 4
\renewcommand{\thechapter}{4}
\chapter{Related Work}

(TODO) sound gradual typing is nominally alive and well


TypeScript implements "occurrence typing" (see "Type Guards and Differentiating Types" of advanced types) and Array as tuple 
\renewcommand{\thechapter}{5}

\chapter{Future Work}

\renewcommand{\thechapter}{6}
\chapter{Conclusion}