%Chapter 1

\renewcommand{\thechapter}{1}

\chapter{Introduction}

Type system defines sets of rules about programs, which can be checked by a machine.
Using a type system, we can assign types to appropriate language concepts like variables, functions and classes to describe how they interact with each other.
This is important for programming languages, as this allows rule violations
to be detected by machines and prevents erroneous part of the program from execution.


The process of checking programs against type rules is called type checking.
It happens either statically ahead of program execution, or dynamically at runtime.
For a statically typed language, ill-typed programs are rejected by compiler and
no executable can be produced until all type errors are fixed. For a dynamically
typed language, type information is examined at runtime and type errors result
in abortion of the program or exceptions being raised
instead of causing segmentation faults or other worse consequences.
They both have their advantages and disadvantages.
For programming languages, different design choices are made to
accommodate their needs.

\section{Strength and Weakness of Both}

In this section we will discuss pros and cons of
statically and dynamically typed languages,
which leads to the motivation of gradual typing - an approach that takes the benefits from two.

\subsection{Dynamically Typed Languages}

A dynamically typed language checks type at runtime, which is best suited for scripting and fast prototyping.
For example, a shell script runs other executables and feeds one's output to another, effectively gluing programs together.
In this case, we have little to no knowledge about the executables ahead of time, making statically type checking impractical.
On the other hand, when it comes to prototyping, it is more important for programmers to execute the code and make modifications accordingly
than to enforce correctness and consistency through whole program.
In such scenario, it is more convenient to delay type checking until
it is required at runtime.


%TODO (commented out due to have no relation to what we are talking)
%These languages also find their presence everywhere: a standard UNIX release usually ships
%with certain scripting languages (bash, perl, awk, to name a few); all modern browsers
%are carried with JavaScript engine which powered most of the nowadays web techniques.
%This also gives normal user an accessible way to program for themselves.

However, a dynamically typed language is not without weakness.
Despite that type checking does not happen ahead of execution,
programmers usually have facts about behaviors of programs,
which is often described in comments or through naming of variables and functions without a systematic way of verifying them.
As program develops, it is easy to make changes and forget updating these descriptions accordingly, which forces future maintainers to go back and rediscover these facts, causing maintenance difficulties.

Furthermore, without type information statically available,
dynamically typed languages have to maintain runtime information and rely on it to implement expected semantics. For example, if it is allowed for a language to condition on non-boolean values, its type has to be available at runtime in order to determine how to cast it into a boolean value.

Optimization opportunities could also be missed for a dynamically type language: 
array cloning can be implemented efficiently as memory copy instructions knowing the array in question contains only primitive values but no reference or pointers, whereas without prior knowledge like this, every element of the array has to be traversed and even recursively cloned.

\subsection{Statically Typed Languages}

Statically typed languages, on the other hand, are better alternatives
when reliability and performance are important for a program.
These languages type checks during compilation, and ill-typed programs are prevented from execution.
With expected behavior described in terms of types, type checking not only ensures that certain kind of errors cannot happen at runtime, but also improves maintainability: it is required for programmers to keep the consistency between type and code, because programs will not compile otherwise.

Having static known type information also helps in terms of efficiency.
For example, In many programming languages, arithmetic functions are polymorphic.
It is allowed for \textbf{a} and \textbf{b} to have different numeric types in \textbf{a + b}, a cast will be inserted to ensure arithmetic primitives only deals with addition of compatible types: if we are adding integer \textbf{b} to a floating number \textbf{a}, then \textbf{b} will be casted so we can call addition primitive that expected floating numbers on both sides.
A dynamic language would have to figure out types of \textbf{a} and \textbf{b} at runtime, make decision about whether casting is required or which primitive addition to call all at runtime. But with type information statically available, these decisions can be made at compile time, resulting in improved efficiency.

%TODO: lack of example

The disadvantage of a statically type language often lies in the lack of flexibility:
if a program need to deal with data whose structure is unknown at compile time,
while a dynamically typed language allows inspecting data of unknown type,
it requires more work for a statically typed language to accept such a program:
because it is impossible to make a precise type about unknown data,
programmers will need extra bookkeeping at runtime to convince the type checker,
effectively creating a type system of their own.

In addition, it is often less convenient for programmers to prototype
in statically typed languages: it involves trial and error to find the best solution
to a problem, which means the ability to write partial programs, make frequent changes to
structure of variables and functions, but these features are not available for a statically
typed language.

%TODO: this might not be related
%less accessible: end-user sees compiled code, won't normally have compiler, build system and toolchain available.

\section{Combining benefits of two}

%TODO could have more to say.

One might have noticed that static type checking and dynamic one
are not mutually exclusive: it is possible to have a program type checked
statically, while allowing runtime type checking.
Indeed, several attempts are motivated to put these two type systems in one,
in hope of bringing in the benefit of both.
In this section, we will discuss about these works.

\subsection{Design Goal}

Summarizing pros and cons of static and dynamic typed languages,
we now have a picture of an ideal type system, it should have following features:

\begin{itemize}
	\item \textbf{Detect and rule out errors ahead of program execution.} This is one main purpose of having a static type system.
	\item \textbf{Delay type checking until needed at runtime.}
	This allows ill-typed or partially written programs to execute.
	Note that this also implies that it should be possible for type checking
	at runtime for this type system.
\end{itemize}

Aside from these two goals within type system, it should be possible for a language equipped with such a type system to make use of the type information available.
As this allows better optimization and type safety both statically and dynamically.
%TODO: more words to say about type safety?

\subsection{A Introduction to Gradual Typing}

\newcommand{\dyn}{\textbf{Dyn}}

Gradual typing is one possible approach that meets our design goal.
It is an extension to static type system.
By introducing a special type, it allows static and dynamic typing to coexist
in one type system.

\subsubsection{Dynamic Type and Type Consistency}

Gradual typing introduces a special type, which is usually called a ``dynamic'' type
(we will use notation \dyn).
Such type captures the idea that type information might be partially known or
unknown at compile time.

With this dynamic type introduced, it is possible for type system to work
even if type information is only partial. In such a case,
the type system only rejects programs that have inconsistencies in known parts of types.

(TODO: type consistency rules here)

For example, type $\dyn \times \textbf{number}$ is consistent with type $\dyn$;
$\textbf{boolean} \rightarrow \dyn$ is consistent with type $\dyn$ and $\dyn \rightarrow \textbf{number}$. But $\dyn \rightarrow \dyn$ is never consistent with $\dyn \times \dyn$, because the former is a function type while the latter a pair.

This extension also allows programs without any type information to pass static 
type checking: when a type is expected for a term but no type information is available,
the term is assumed to have a dynamic type. Therefore no inconsistency can be detected
statically to reject the program.

%\subsubsection{Gradually Typed Lambda Calculus}

%vs. simply typed and untyped

%\subsubsection{Blame Calculus}

%For providing a means to track down source of violation correctly.

%\subsubsection{Gradual Guarantee}

%What does it mean to be gradually typed (formally)

\subsubsection{Optional Type Annotation and ``pay-as-you-go''}

Gradual typing enables static and dynamic typing within one type system,
but what more important is that it creates a middle ground in which programs
can be partially typed: all type annotations are not required for a gradual type system,
but when programmers do annotate terms with types,
the type system will be responsible to make sure that type annotations are consistent
within programs.

For example, one might wish to implement a function $f$ that expects a string value
as input. There are two approaches: we can either give $f$ a type annotation:
$f : \textbf{string} \rightarrow \dyn$. By doing so, type system takes the responsibility
of making sure that the input type is indeed a string. Alternatively,
we can inspect type of the input value at runtime ourselves.

A static type system allows us to do the former, but a return type must either
be given explicitly or inferred. And a dynamic type system does the later, but
we cannot statically detect any mistake like applying a number literal to $f$.
However, a gradual type system allows us to give input value a type
without worrying about giving a return type if not needed.
More generally, programmer only pays for what they want from a type system.

%TODO more to say

\subsubsection{Runtime Checks and Cast Insertion}

%TODO: should also have other things to be discussed: subtyping, higher-order types

When dynamic types are present, it is not always possible to type check the whole
program statically: applying a variable $x : \dyn$ to a function $f : number \rightarrow \dyn$ is consistent, but at runtime $x$ might turn out to be a function, which becomes inconsistent
with $f$. Therefore, gradual typing inserts type casts into the program to allow
more type errors to be detected at runtime.

%TODO: from Gradual Typing for Functional Languages

\subsection{Alternatives}

There are other alternatives to gradual typing.

Soft typing: introduces type inference for dynamically-typed languages.

Contracts: is a runtime system.

Liquid type: uses logic terms and verify them through a solver.

Refinement type: works similarly?

Dependent type
%TODO lambda calculus all the way down?

\subsection{Discussion}

Despite that there are various research works that combines
benefit of static and dynamic type checking
gradual typing remains one of the most popular approach:
thanks to gradual guarantee, an existing language can be extended to
support gradual typing while all existing programs written in it is still valid
with no difference in semantics. In addition, the cost of gradual typing pays
as programmers need.

%TODO: more to say

However, it is not a straightforward work to support gradual typing for existing languages.
In chapter 2, we will explore some research works that extends existing popular languages.
Common challenges and solutions while extending an existing language is discussed in chapter 3.
Open questions in chapter 4.

