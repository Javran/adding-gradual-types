%Chapter 1

\renewcommand{\thechapter}{1}

\chapter{Introduction}

Type system defines sets of rules about programs, which can be checked by a machine
in a systematic way.
With a type system, one can assign types to appropriate language concepts like variables, functions and classes to describe expected behaviors and how they interact with each other.
Then type system takes the responsibility of ensuring that types are respected and
type errors prevent erroneous part of a program from execution.

There are other benefits of type systems besides automated checking:
types can be used to reveal optimization opportunities,
can serve as simple documentation to programmers or
provide hints to development tools to automate navigation, documentation lookup
or auto-completion.

All these benefits make type system an important part of programming languages,
and there are different ways of accommodating languages with type systems.
The most noticeable difference is the process of checking programs again type rules,
which is also known as type checking.
It occurs either statically ahead of program execution, or dynamically at runtime.
For a static type system, ill-typed programs are rejected by compiler and
no executable can be produced until all type errors are fixed.
For a dynamic type system, type information is examined at runtime and type errors result
in abortion of the program or exceptions being raised
instead of causing segmentation faults or other worse consequences.
Static and dynamic type system both have their advantages and disadvantages,
and languages make different choices depending on their needs.

In this chapter, we start off by discussing static and dynamic type systems,
which motivates research works that attempted to combine both within one system
in order to take benefits from two,
which in return gives birth to gradual typing.

\section{Strength and Weakness of Static and Dynamic Typing}

The difference between static and dynamic typing is the difference
between whether type checking occurs ahead of execution or at runtime.
This section discusses advantages and disadvantages of both.

\newcommand{\tnum}{\textbf{num}}
\newcommand{\tstr}{\textbf{str}}
\newcommand{\tbool}{\textbf{bool}}
\newcommand{\tarr}[2]{#1 \rightarrow #2}

In this section we use $T_0, T_1, \ldots$ for type variables.
$\tbool$, $\tnum$ and $\tstr$ are types of
boolean values, fixed point numbers and strings respectively.
And the type notation for functions that takes as input $T_0, T_1, \ldots$
and returns a value of $T_2$ is $\tarr{(T_0, T_1, \ldots)}{T_2}$.
We use $o : T$ to mean that a language object $o$ is assigned a type $T$.
For example $f : \tarr{(\tnum, \tnum)}{\tnum}$ is a function that
takes two numbers as input and returns a number.
In addition, tuple types are notated as $(T_0, T_1, \ldots)$

\subsection{Static Type Systems}

%TODO: type system or language?

A static type system is preferred if robustness and performance
is the main goal of a language.
Because type checking occurs ahead of execution,
ill-typed programs are rejected before it can start, and
when a program typechecks,
one can therefore expect no type error to occur and
no extra cost is paid for typechecking at runtime.

% TODO: could have more to say about type inference

For a static type system to work, all variables, functions, etc. in a program
will need to be assigned types. This is usually done by programmers or through the
means of type inference, which is a technique that infers types using
available type information. This is both an advantage and a disadvantage
of a static type system: having type annotations improves readability
and since programmers are required to keep the consistency between type and code,
type also serves as simple, faithful documentation. But on the other hand,
adding and maintaining type annotations can also considered a burden.

Having static known type information also helps in terms of performance in other ways.
For example, In many programming languages, arithmetic functions are polymorphic.
It is allowed for \textbf{a} and \textbf{b} to have different numeric types in \textbf{a + b}, a cast will be inserted to ensure arithmetic primitives only deals with addition of compatible types: if we are adding integer \textbf{b} to a floating number \textbf{a}, then \textbf{b} will be casted so we can call addition primitive that expected floating numbers on both sides.
A dynamic language would have to figure out types of \textbf{a} and \textbf{b} at runtime, make decision about whether casting is required or which primitive addition to call all at runtime. But with type information statically available,
these decisions can be made ahead of execution,
resulting in improved performance at runtime.

Besides extra effort of maintaining type annotations,
the disadvantage of a statically type language often lies in the lack of flexibility:
if a program need to deal with data whose structure is unknown at compile time,
while a dynamically typed language allows inspecting data of unknown type,
it requires more work for a statically typed language to accept such a program:
because it is impossible to make a precise type about unknown data,
programmers will have to use an imprecise type
and keep extra information at runtime,
effectively creating a dynamic type system of their own.

In addition, it is often less convenient for programmers to prototype
in statically typed languages: it involves trial and error to find the best implementation
to solve a problem, which means the ability to write partial programs,
make frequent changes to structure of variables and functions, but these features are not easily available for a statically typed language.

%TODO: this might not be related
%less accessible: end-user sees compiled code, won't normally have compiler, build system and toolchain available.

\subsection{Dynamic Type System}

Dynamic type system does typechecking at runtime, which is best suited for
languages designed for scripting and fast prototyping.
A shell script, for example, runs other executables and feeds one's output to another, effectively gluing programs together.
In such a case, we have little to no knowledge about these executables ahead of time,
making statically type checking impractical.
And when it comes to prototyping,
it is more important for programmers to execute the code and make modifications accordingly
than to enforce correctness and consistency through whole program.
In such scenario, it is more convenient to delay type checking until
it is required at runtime.

%TODO (commented out due to have no relation to what we are talking)
%These languages also find their presence everywhere: a standard UNIX release usually ships
%with certain scripting languages (bash, perl, awk, to name a few); all modern browsers
%are carried with JavaScript engine which powered most of the nowadays web techniques.
%This also gives normal user an accessible way to program for themselves.

However, it is also easy to spot weaknesses of dynamic type systems.
Despite that type checking does not happen ahead of execution,
programmers usually have facts about behaviors of programs,
which is often described in comments or through naming of variables and functions without a systematic way of verifying them.
As program develops, it is easy to make changes and forget updating these descriptions accordingly, which forces future maintainers to go back and rediscover these facts, causing maintenance difficulties.

%TODO: throw error at runtime

Furthermore, without type information statically available,
dynamic type system needs to maintain runtime information
and rely on it to implement expected semantics.
For example, if it is allowed for a language to condition on non-boolean values,
its type has to be available at runtime in order to
determine how to cast it into a boolean value at runtime.

Optimization could also be hindered for a dynamically type language: 
array cloning can be implemented efficiently as memory copy instructions knowing the array in question contains only primitive values but no reference or pointers, whereas without prior knowledge like this, every element of the array has to be traversed and even recursively cloned.


\section{Combining benefits of two}

%TODO could have more to say.

One might have noticed that static type checking and dynamic one
are not mutually exclusive: it is possible to have a program typechecked
statically, while allowing runtime type checking.
While static type system does typechecking ahead of time
and avoids runtime overhead,
it lacks the ability of using runtime type information;
dynamic type system does typechecking at runtime,
but it requires sophisticated work to reduce the amount of
unnecessarily repeated runtime checks.
In hope of bringing in benefits of both,
several attempts are motivated to put these two type systems in one.
In this section, we will discuss about these research works.

\subsection{Design Goal}


Summarizing pros and cons of static and dynamic typed languages,
we now have a picture of an ideal type system, it should have following features:

\begin{itemize}
	\item \textbf{Detect and rule out errors ahead of program execution.} This is one main purpose of having a static type system. When a program starts running,
	type errors should already be eliminated and runtime overhead should be minimized
	to keep its performance close to that of a static type system.
	\item \textbf{Delay typechecking until needed at runtime.}
	This is the crucial feature of a dynamic type system,
	it allows ill-typed or partially written programs to execute,
	which makes it suitable in situations where static type information
	is limited or fast prototyping is preferred over robustness or runtime performance.
\end{itemize}

Aside from these two goals, type annotations can also be used for
other purposes like optimization and providing hints to development tools.
For a language with this new type system, it should also be possible.

\subsection{A Introduction to Gradual Typing}

\newcommand{\dyn}{\textbf{dyn}}

Gradual typing is one possible approach that meets our design goal.
It captures the fact that type information might only be partially known
ahead of execution by introducing a special type that indicates partial types.
It attempts to typecheck programs like a static type system does, but delays
typechecking on partial types until sufficient type information is available
at runtime.

In the following sections, we will introduce it
as an extension to static type system.
But it is also possible and practical to support gradual typing by
extending a dynamic type system.

In the following sections, notation $\dyn$ will be used for
special types mentioned above, which is also known as dynamic types.

\subsubsection{Dynamic Type and Type Consistency}

Gradual type system introduces a dynamic type on top of a static type system
to capture the idea that type information might only be partially known
ahead of execution.

To deal with dynamic types, we introduce type consistency
to accommodate type judgments for gradual typing.
Figure ? shows rules for type consistency relation.

(TODO: type consistency rules here, lambda calculus without data type)

In general, two types are consistent when
their type structures do not conflict with each other.
For example, $\tbool$ is consistent with type $\dyn$
despite that the latter is less precise;
$\tarr{\tnum}{\dyn}$ is consistent with $\tarr{\dyn}{\tnum}$ and $\tarr{\dyn}{\dyn}$,
because all these types are functions that accepts one value and returns another and
$\tnum$ and $\dyn$ are consistent with each other.
However $\tarr{\dyn}{\dyn}$ is never consistent with $\tbool$,
because the former is a function type while the latter a boolean value,
whose type structures do not match.

By introducing dynamic type, gradual typing provides
typechecking ahead of execution that accepts both statically and dynamically typed programs: 
when no dynamic type is involved, typechecking proceeds in the
exactly same way as that of a static type system.
There might be no type annotation in dynamically typed programs,
in which case types of terms are default to $\dyn$, which allows
then to typecheck, without raising type errors.

%\subsubsection{Gradually Typed Lambda Calculus}

%vs. simply typed and untyped

%\subsubsection{Blame Calculus}

%For providing a means to track down source of violation correctly.

%\subsubsection{Gradual Guarantee}

%What does it mean to be gradually typed (formally)

\subsubsection{Optional Type Annotation and ``pay-as-you-go''}

So far we have seen that gradual type system introduces a dynamic type,
which allows accepting both statically and dynamically typed programs during static typechecking.
But what is more important is that it creates a middle ground in which programs
can be partially annotated with types:
in a gradual type system, terms are either explicitly given a type,
or, when type annotation is missing, given $\dyn$ type.
This renders all type annotations to be optional and allows programmers
to have more control over what they need from typechecking:
for an originally statically typed program, we can now write terms without giving a type,
this allows easy prototyping; for an originally dynamically typed program,
some parts of it might already been stable and robust enough, annotating these parts
with type allows some effort of ensuring correctness being shifted to typechecking.

For example, one might wish to implement a function $f$ that expects a string value
as input. There are two approaches: we can either give $f$ a type annotation:
$f : \textbf{string} \rightarrow \dyn$. By doing so, type system takes the responsibility
of making sure that the input type is indeed a string. Alternatively,
we can inspect type of the input value at runtime ourselves.

A static type system allows us to do the former, but a return type must either
be given explicitly or inferred. And a dynamic type system does the later, but
we cannot statically detect any mistake like applying a number literal to $f$.
However, a gradual type system allows us to give input value a type
without worrying about giving a return type if not needed.
More generally, programmer only pays for what they want from a type system.

%TODO more to say

\subsubsection{Runtime Checks and Cast Insertion}

%TODO: should also have other things to be discussed: subtyping, higher-order types

When dynamic types are present, it is not always possible to type check the whole
program statically: applying a variable $x : \dyn$ to a function $f : number \rightarrow \dyn$ is consistent, but at runtime $x$ might turn out to be a function, which becomes inconsistent
with $f$. Therefore, gradual typing inserts type casts into the program to allow
more type errors to be detected at runtime.

%TODO: from Gradual Typing for Functional Languages

\subsection{Alternatives}

There are other alternatives to gradual typing.

Soft typing: introduces type inference for dynamically-typed languages.

Contracts: is a runtime system.

Liquid type: uses logic terms and verify them through a solver.

Refinement type: works similarly?

Dependent type
%TODO lambda calculus all the way down?

\subsection{Discussion}

Despite that there are various research works that combines
benefit of static and dynamic type checking
gradual typing remains one of the most popular approach:
thanks to gradual guarantee, an existing language can be extended to
support gradual typing while all existing programs written in it is still valid
with no difference in semantics. In addition, the cost of gradual typing pays
as programmers need.

%TODO: more to say

However, it is not a straightforward work to support gradual typing for existing languages.
In chapter 2, we will explore some research works that extends existing popular languages.
Common challenges and solutions while extending an existing language is discussed in chapter 3.
Open questions in chapter 4.

